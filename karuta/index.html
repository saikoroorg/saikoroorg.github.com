<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<title>Karuta</title>
<link rel="icon" type="image/svg" href="icon.svg">
<link rel="apple-touch-icon" href="icon.png" sizes="192x192">
<script src="manifest.js"></script>
<style>
body {
	font-family: Courier, monospace, sans-serif;
	background-color: #fff;
}
a {
	color: #000;
	text-decoration: none;
}
#container {
	width: 100%; height: 100%;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: flex-start; -webkit-justify-content: flex-start;
	align-items: center; -webkit-align-items: center;
}
#header {
	width: 95%; margin: 0px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: space-between; -webkit-justify-content: space-between;
	align-items: center; -webkit-align-items: center;
}
#contents {
	position: relative;
	width: 95%; height: 90%;
	flex: 1 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	background-color: #eee;
}
#footer {
	width: 95%; margin: 0px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: flex-end; -webkit-justify-content: flex-end;
	align-items: center; -webkit-align-items: center;
}
#author,#version {
	font-size: 12px;
	opacity: 0.06;
}
#logo {
	height: 60px;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: flex-start; -webkit-justify-content: flex-start;
	align-items: center; -webkit-align-items: center;
}
#icon {
	width: 40px; height: 40px; margin-right: 10px;
	background-image: url('resource.svg');
}
#title {
	margin: 0px;
	font-size: 24px;
}
#menu {
	width: 120px; height: 40px;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	opacity: 0.5;
}
#menu a {
	width: 40px; height: 44px;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	color: #000;
	font-size: 30px;
	text-decoration: none;
	transform: scale(1);
	opacity: 1;
}
#menu a:hover {
	transform: scale(1);
	opacity: 0.6;
}
#menu a:active {
	transform: scale(0.9);
	opacity: 1;
}
@media (max-height: 479px) {
	#logo {
		height: 20px;
	}
	#icon {
		margin-left: -12px;
		margin-right: -8px;
		transform: scale(0.4);
	}
	#title {
		font-size: 12px;
	}
	#menu {
		height: 20px;
	}
	#menu a {
		font-size: 12px;
	}
	#author,#version {
		height: 10px;
		font-size: 8px;
	}
}
</style>
</head>
<body>
<div id="container">
	<h1 id="header">
		<a href="?" id="logo">
			<div id="icon"></div>
			<div id="title">Karuta</div>
		</a>
		<div id="menu">
			<a href="javascript:changeCounts(-1);">-</a>
			<a href="javascript:changeMaximum();">|</a>
			<a href="javascript:changeCounts(+1);">+</a>
		</div>
	</h1>
	<div id="contents" class="cubeScreen"></div>
	<h6 id="footer">
		<div id="author">.</div>
		<div id="version">.</div>
	</h6>
</div>
<script src="cube-api-0.8.js"></script>
<!--Resource!--><script>
	var buffers = [null, null]; // Original design buffer.

	// Query parameters.
	//  McN/S   : M = Hand card maximum, N = Deck card maximum, S = Suit counts.
	//  &r=1234 = Random seed, p
	//  &p=1/3  = Deck sharing identifier.
	//  &n1~n13 = Card face number design.
	//  &f1~f4  = Card face design.
	//  &f5     = Card face dummy/joker design.
	//  &f6     = Card back design.
	//  &c1~c6  = Color palette.
	var keys = cubeParamKeys();

	// BACK:  f21f31f41f51f61f71f81f22f42f62f82f23f33f53f73f83f24f44f64f84f25f35f55f75f85f26f46f66f86f27f37f57f77f87f28f48f68f88f29f39f49f59f69f79f89
	// SPADE: c53c44c54c64c35c45c55c65c75c36c46c56c66c76c47c57c67
	// HEART: a43a63a34a44a54a64a74a35a45a55a65a75a46a56a66a57
	// DIAM:  d53d44d54d64d35d45d55d65d75d46d56d66d57  
	// CLUB:  b43b53b63b44b54b64b35b45b55b65b75b36b46b56b66b76b57
	// JOKER: e33e73e44e54e64e45e55e65e46e56e66e37e77
	// JACK:  f53f63f64f65f46f66f57f67
	// QUEEN: f43f53f63f44f64f45f65f46f56f67
	// KING:  f43f63f44f64f45f55f46f66f47f67
	// COLOR: fff d66 6b6 66d bb4 888 000


	// BACK:  e21081e29089e22028e82088e42e62e33e53e73e44e64e35e55e75e46e66e37e57e77e48e68
	// SPADE: c44067c35076c53054
	// HEART: a44066a34075a43044a63064a56057
	// DIAM:  d44066d53057d35075  
	// CLUB:  b43066b54057b35076
	// JOKER: e33e73e44066e37e77
	// JACK:  f53f63067f46f57
	// QUEEN: f43063f43046f63065f56f67
	// KING:  f43047f63064f66067f55
	// COLOR: d66 6b6 66d bb4 888 000

	// Example 1: Standard playing cards.
	// 5c54&f0=g21089&f1=c44067c35076c53054&f2=a44066a34075a43044a63064a56057&f3=d44066d53057d35075&f4=b43066b54057b35076&f5=e21e41e61e81e23e83e25e85e27e87e29e49e69e89&f6=e21081e29089e21029e81089e42e62e33e53e73e44e64e35e55e75e46e66e37e57e77e48e68&n1=f53f63067f46f57&n2=f43063f43046f63065f56f67&n3=f43047f63064f66067f55&c1=d66&c2=6b6&c3=66d&c4=bb4&c5=888&c6=000&c7=fff

	// Example 2: Highreso playing cards.
	// 5c54&n0=gee&n1=f53f44047f64067f56&n2=f43063f64f45065f46f47067&n3=f43063f45065f47067f63067&n4=f43045f45065f63067&n5=f43063f44f45065f66f47067&n6=f43063f43047f45065f66f47067&n7=f43063f44f63067&n8=f43063f43047f55f63067f47067&n9=f43063f43045f45065f64067f47067&n10=f43047f63083f63067f83087f67087&n11=f53f63067f46f57&n12=f43063f43046f63065f56f67&n13=f43047f63064f66067f55&c1=d66&c2=6b6&c3=66d&c4=bb4&c5=888&c6=000&c7=fff

	// Example 3: Dice design cards.
	// 3c21&f0=g11099f11091f11018f91098f19099&f1=c53c44c54c64c35c45c55c65c75c36c46c56c66c76c47c57c67&f2=a43a63a34a44a54a64a74a35a45a55a65a75a46a56a66a57&f3=d53d44d54d64d35d45d55d65d75d46d56d66d57&f4=b43b53b63b44b54b64b35b45b55b65b75b36b46b56b66b76b57&f5=f11091f11018f91098f19099&f6=f11091f11018f91098f19099e33e73e44e54e64e45e55e65e46e56e66e37e77&n1=f55&n2=f73f37&n3=f73f55f37&n4=f33f73f37f77&n5=f33f73f55f37f77&n6=f33f73f35f75f37f77&n7=f33f73f35f55f75f37f77&n8=f33f53f73f35f75f37f57f77&n9=f33f53f73f35f55f75f37f57f77&c1=d66&c2=6b6&c3=66d&c4=bb4&c5=888&c6=000&c7=fff

	// Load color palette parameters.
	var depth = 3, palette = [[255,255,255]];
	for (let j = 0; j <= keys.length; j++) {
		let data = cubeParamData("c"+ j);
		if (data.length >= depth) {
			let d = cubeDiv(data.length, depth); // d=1:RGB, d=2:RRGGBB.
			palette[j] = [];
			for (let i = 0; i < depth; i++) {
				palette[j][i] = data[i * d] * 16 + data[(i + 1) * d - 1];
			}
		}
	}

	// Load face design parameters.
	let designsMax = [0, 0], designsKeys = ["f", "n"];
	var bufferPixel = 2, bufferWidth = 9, bufferOffset = 1, bufferScale = 2;
	var designs = [[], []];
	designs[0] = [[[1,1,18,18,255,255,255]]]; // Face side design.
	for (let k = 0; k < designsKeys.length; k++) {
		for (let j = 0; j <= keys.length; j++) {
			let data = cubeParamData(designsKeys[k] + j);
			for (let i = 0; i < data.length; i += 3) {
				let x = data[i + 1], y = data[i + 2];
				if (x > bufferWidth || y > bufferWidth) {
					if (x > 16 || y > 16) {
						bufferPixel = 1;
						bufferWidth = 32;
						bufferOffset = 4;
						bufferScale = 1;
					} else if (x > 9 || y > 9) {
						bufferPixel = 1;
						bufferWidth = 16;
						bufferOffset = 2;
						bufferScale = 2;
					}
					while (x > bufferWidth || y > bufferWidth) {
						bufferWidth = bufferWidth * 2;
						bufferOffset = bufferOffset * 2;
						bufferScale = bufferScale / 2;
					}
					designs[k] = [[[
						bufferOffset,
						bufferOffset,
						bufferWidth + bufferOffset - 1,
						bufferWidth + bufferOffset - 1,
						255, 255, 255]]];
				}
			}
		}
	}
	for (let k = 0; k < designsKeys.length; k++) {
		for (let j = 0; j <= keys.length; j++) {
			let data = cubeParamData(designsKeys[k] + j);
			if (data.length > 0) {
				designs[k][j] = [];
				let w = 2;
				if (j > 0) {
					designsMax[k] = j > designsMax[k] ? j : designsMax[k];
					if (j > 0 && designs[k][0]) {
						let rects = designs[k][0];
						for (let i = 0; i < rects.length; i++) { // designs[0] = Common design.
							designs[k][j].push(rects[i]);
						}
					}
				}
				for (let i = 0; i < data.length; i += 3) {
					let x = (data[i + 1] - 1) * bufferPixel + bufferOffset;
					let y = (data[i + 2] - 1) * bufferPixel + bufferOffset;
					if (x > 0 && y > 0) {
						let color = data[i] >= 10 ? data[i] - 9 : data[i];
						let r = palette[color] ? palette[color][0] : 0;
						let g = palette[color] ? palette[color][1] : 0;
						let b = palette[color] ? palette[color][2] : 0;
						//let rect = [x, y, x + bufferPixel - 1, y + bufferPixel - 1, r, g, b];

						let x2 = data[i + 1] * bufferPixel - 1 + bufferOffset;
						let y2 = data[i + 2] * bufferPixel - 1 + bufferOffset;
						if (i < data.length - 3 && data[i + 3] == 0) {
							x2 = data[i + 4] * bufferPixel - 1 + bufferOffset;
							y2 = data[i + 5] * bufferPixel - 1 + bufferOffset;
							i += 3;
						}
						let rect = [x, y, x2, y2, r, g, b];
						designs[k][j].push(rect);
					}
				}
			}
		}
	}

	// Create pixel buffer for face design.
	let size = bufferWidth * bufferPixel + bufferOffset * 2;
	if (designs[0].length > 1) {
		buffers[0] = cubeBuffer(size, size, bufferScale, designsMax[0]);
		for (let i = 1; i < designs[0].length; i++) {
			if (designs[0][i]) {
				cubeBufferRects(designs[0][i], i - 1, buffers[0]);
			}
		}
	}
	if (designs[1].length > 1) {
		buffers[1] = cubeBuffer(size, size, bufferScale, designsMax[1]);
		for (let i = 1; i < designs[1].length; i++) {
			if (designs[1][i]) {
				cubeBufferRects(designs[1][i], i - 1, buffers[1]);
			}
		}
	}
</script><!--/Resource-->

<!--Menu--><script>
//	console.log = () => {};
	document.querySelector("#author").innerText = manifest.author + manifest.scope;
	document.querySelector("#version").innerText = "#" + manifest.version.substr(-4);
	document.querySelector("#logo").href = window.location.search;

	// Get query parameters.
	var params = cubeParamNumbers(0);
	var counts = params[0] > 0 ? params[0] : 5; // Hand card counts.
	var deckMaximum = params[1] >= 0 ? params[1] : 52; // Deck card maximum.
	var handMaximum = deckMaximum < 54 ? deckMaximum : 54; // Hand card maximum.
	var colors = params[2] >= 0 ? params[2] : 4; // Card kind counts.
	var original = 0; // Original design icon frame.
	var rolling = 0; // Rolling count.

	// Set counts of cards.
	var setCounts = (x) => {
		counts = (x > 20) ? 20 : (x < 0) ? 0 : x;
		rolling = -1; // Reroll.
	};

	// Set maximum number.
	var setMaximum = (x) => {
		deckMaximum = (x > 80) ? 80 : (x < 0) ? 0 : x;

		// Reset card icon.
		var icon = document.getElementById("icon");
		if (icon) {
			var iconFrameMax = cubeDiv(deckMaximum, colors);
			if (buffers[0]) {
				icon.style.backgroundImage = "url(\"" + buffers[0].toImage() + "\")";
				original = original + 1 <= iconFrameMax ? original + 1 : 1;
				var nx = -cubeMod(original - 1, iconFrameMax) * 40;
				var ny = -cubeDiv(original - 1, iconFrameMax) * 40;
				icon.style.position = "2 0";
				icon.style.backgroundPosition = "" + nx + " " + ny;
			} else {
				var n = deckMaximum == 52 ? 6 : deckMaximum == 54 ? 5 : deckMaximum == 0 ? 10 :
					deckMaximum < 56 ? cubeDiv(deckMaximum, 4) + 7 : cubeDiv(deckMaximum, 4) + 10;
				var nx = -cubeMod(n - 1, iconFrameMax) * 40;
				var ny = -cubeDiv(n - 1, iconFrameMax) * 40;
				icon.style.position = "0 0";
				icon.style.backgroundPosition = "" + nx + " " + ny;
			}
		}

		rolling = -2; // Restart.
	};

	var changeCounts = (x) => {
		setCounts(counts + x);
	};
	var changeMaximum = () => {
		if (buffers[0]) {
			setMaximum(deckMaximum);
		} else {
			setMaximum(deckMaximum = deckMaximum == 52 ? 54 : deckMaximum == 54 ? 0 : 52);
		}
	};

	// Initialize settings.
	setCounts(counts);
	setMaximum(deckMaximum);
</script><!--/Menu-->

<!--Main--><script>(async()=>{
	//var handMaximum = 1; // Maximum hand counts.
	//var deckMaximum = 6; // Maximum deck counts.
	//var rolling = 0; // Rolling count.

	var courts = buffers[1] ? buffers[1].frames : (deckMaximum > 0 && deckMaximum < 56) ? 3 : 0; // Court card kinds.
	var jokers = deckMaximum > 0 ? cubeMod(deckMaximum, colors) : 0; // Joker card kinds.
	var numberMax = deckMaximum > 0 ? cubeDiv(deckMaximum, colors) : 10; // Card deckMaximum number.
	//console.log("deckMaximum=" + deckMaximum + " colors=" + colors + " courts=" + courts + " jokers=" + jokers + " numberMax=" + numberMax)

	// Resize screen.
	cubeResizeScreen(300, 300);

	// Create sprites.
	var sprites = [];
	for (var i = 0; i < 2; i++) {
		sprites[i] = await cubeSprite("resource.svg", 40, 40);
	}

	//var sprite0 = buffers[0] ? await cubeBufferSprite(buffers[0]) : null;
	//var sprite1 = buffers[1] ? await cubeBufferSprite(buffers[1]) : null;

	var sprites0 = [], sprites1 = [], sprites2 = [];
	for (var i = 0; i < 32; i++) {
		if (buffers[0]) {
			sprites0[i] = await cubeBufferSprite(buffers[0]);
		} else {
			sprites0[i] = await cubeSprite("resource.svg", 40, 40);
		}
		if (buffers[1]) {
			sprites1[i] = await cubeBufferSprite(buffers[1]);
		} else {
			sprites1[i] = await cubeSprite("resource.svg", 40, 40);
		}
		sprites2[i] = await cubeSprite("resource.svg", 40, 40);
	}

	// Sprite frame.
	var frameMax = deckMaximum > 0 ? deckMaximum : 10 * colors;
	var frameMin = deckMaximum > 0 ? 1 : 0;
	var colorFrameMax = colors;
	var courtFrameMax = courts;
	var numberFrameMax = numberMax;

	// Decks.
	var decks = [], trashes = [], numbers = [];
	var handCounts = drawCounts = newCounts = 0;

	// Main loop.
	var counter = 0;
	while (true) {

		// Shuffle by Fisher-Yates argorythm.
		if (rolling < 0) {
			frameMax = deckMaximum > 0 ? deckMaximum : 10 * colors;
			frameMin = deckMaximum > 0 ? 1 : 0;

console.log("deckMaximum=" + deckMaximum + " frameMax=" + frameMax + " counts=" + counts)

			handCounts = drawCounts = newCounts = 0;
			decks = [];
			trashes = [];
			numbers = [];
			for (let j = 0; j < frameMax; j++) {
				decks[j] = j;
			}
			for (let i = decks.length - 1; i > 0; i--) {
				let j = cubeRandom(i + 1);
				let d = decks[i];
				decks[i] = decks[j];
				decks[j] = d;
			}
		}

		// Sprite lines and rows.
		//var lineMax = cubeSqrt(handCounts - 1) + 1;
		//var lines = cubeDiv(handCounts - 1, lineMax) + 1;
		//var rows = [];
		//for (var i = 0; i < lines; i++) {
		//	rows[i] = i > 0 ? lineMax : (cubeMod(handCounts - 1, lineMax) + 1);
		//}

		// Discard hand cards.
		while (counts < handCounts && numbers.length > 0) {
			trashes.push(numbers.shift());
			handCounts = handCounts - 1;
			newCounts = 0;
		}

		// Move trashes to decks.
		//while (trashes.length > 0) {
		//	let i = cubeRandom(trashes.length);
		//	decks.push(trashes.splice(i, 1));
		//}

		// Draw initial card from decks.
		while (counts > handCounts && decks.length - drawCounts > 0) {
			rolling = -1;
			handCounts += 1;
			drawCounts += 1;
			newCounts = 0;
		}
		counts = handCounts;

		// Sprite scale and angle.
		var angle = 0;

		// Drawing card.
		var result = 0;
		for (rolling = 1; rolling >= 1; rolling++) {

			// Screen size.
			var size = cubeScreenSize();
			// Wait for input.
			await cubeReadJoypad(0);
			let action = cubeJoypadAction();
			let motion = cubeJoypadMotion();
			if (result > 0) {

				if (action) {
					for (let i = 0; i < handCounts + 2; i++) {
						if (cubeCheck(motion, sprites0[i])) {
							
							// Discard hand card to trashes.
							if (i < handCounts) {
								trashes.push(numbers.splice(i, 1));
								counts = handCounts = handCounts - 1;
								break;
							}

							// Touch decks.
							if (i == handCounts + 1) {

								// Move trashes to decks.
								if (decks.length == 0) {
									while (trashes.length > 0) {
										let i = cubeRandom(trashes.length);
										decks.push(trashes.splice(i, 1));
									}

								// Draw card from decks.
								} else if (rolling > 10 && decks.length - drawCounts > 0) {
									result = 0;
									rolling = 0;
									if (handCounts < frameMax) {
										counts = handCounts = handCounts + 1;

									// Auto trash.
									//} else if (drawCounts < frameMax) {
									//	trashes.push(numbers.shift())
									//}
									//
									// Add drawing card counts.
									//if (drawCounts < handCounts) {

										drawCounts += 1;
									}
									newCounts = 0;
								}

								break;
							}
						}
					}
				}
			} else {


				// Add drawing cards.
				if (motion) {
					if (rolling > 5 && decks.length - drawCounts > 0) {
						if (handCounts < frameMax) {
							counts = handCounts = handCounts + 1;

						// Auto trash.
						//} else if (drawCounts < frameMax) {
						//	trashes.push(numbers.shift())
						//}
						//
						// Add drawing card counts.
						//if (drawCounts < handCounts) {

							drawCounts += 1;
						}
						newCounts = 0;
					}
					rolling = 1;

				// Timeout and show result.
				} else if (rolling > 20) {
					result = 1;

					// Set face numbers.
					for (var i = handCounts - drawCounts; i < handCounts; i++) {
						numbers[i] = decks.pop();
					}

					// Set drawing cards to new cards.
					newCounts = drawCounts;
					drawCounts = 0;

					angle = 0;
					rolling = 1;
					counter++;
				}
			}

			// Roll sprites.
			if (result <= 0) {
				angle = cubeMod(angle + 20, 360);
			}

			// Positions.
			var mx = size.x * 0.8, my = size.y * 1;
			var ox = (size.x - mx) * 0.5, oy = (size.y - my) * 0.5;

			// Update counter sprite.
			/*for (let i = 0; i < 2; i++) {
				let imod2 = cubeMod(i, 2);
				let sx = ox + mx * (5 - imod2 * 2) / 6;
				let sy = oy + my * 4 / 10; //16 + i2 * 24; //@todo sukoshi ueme.
				let c = imod2 <= 0 ? decks.length - drawCounts : trashes.length; //@todo sukoshi ueme.
				let m = c > 55 ? 65 : c > 0 ? c + 9 : 9;
				cubeAnimate(m, sprites[i]);
				cubeDilute(0.2, sprites[i]);
				cubeExpand(0.5, sprites[i]);
				cubeMove(sx, sy, sprites[i]);
			}*/

			let lineMax = 5;//frameMax > 7 ? cubeSqrt(handCounts - 1) + 1 : 7;
			let lines = cubeDiv(handCounts - 1, lineMax) + 1;
			var scale = 5 / ((handCounts < lineMax ? handCounts : lines >= lineMax ? lines : lineMax) + 1);

			// Update sprites.
			for (let i = 0; i < handCounts + 2; i++) {
				{
					let y = cubeDiv(i, lineMax);
					let x = cubeMod(i, lineMax);
					let rows = y < lines - 1 ? lineMax : (cubeMod(handCounts - 1, lineMax) + 1);

			//for (var y = 0; y < lines; y++) {
			//	for (var x = 0; x < rows[y]; x++) {
			//		var i = lineMax * y + x;

					// Scale animation.
					var s = scale;
					if (rolling < 5 && (i >= handCounts - drawCounts || i >= handCounts - newCounts)) {
						s = scale * (0.8 + 0.04 * rolling);
					}

					//var sx = ox + mx * (x + 1) / (rows[y] + 1);
					//var sy = oy + my * (y + 1) / (lines + 1);

					let sx = ox + mx * (x + 1) / (rows + 1);
					let sy = oy + my * (y + 7) / (lines + 8); //@todo: sukoshi shita position.
					let n = numbers[i];

					if (i >= handCounts) {
						let j = i - handCounts, m = 9;

						// Trash counts.
						if (j == 0) {
							let c = trashes.length;
							m = c > 55 ? -2 : c > 0 ? c + 9 : 9;
							s = 2.5;
							sx = ox + mx * 3 / 6;
							sy = oy + my * 2 / 9; //@todo sukoshi ue position.
							n =  c > 0 ? trashes[trashes.length - 1] : -2;
						}
						// Deck counts.
						if (j == 1) {
							let c = decks.length - drawCounts;
							m = c > 54 ? -2 : c > 0 ? c + 9 : 9;
							s = 1.0;
							sx = ox + mx * 5 / 6;
							sy = oy + my * 2 / 9; //@todo sukoshi ue position.
							n =  c > 0 ? -1 : -2;

						}

						//if (n >= -1) {
							cubeAnimate(m, sprites[j]);
							cubeDilute(0.2, sprites[j]);
							cubeExpand(0.5, sprites[j]);
							cubeMove(sx, sy + s * 20 + 10, sprites[j]);
						//} else {
						//	cubeDilute(0, sprites[j]);
						//	cubeExpand(0, sprites[j]);
						//}
					}

					// No cards.
					/*if (n < -1) {
						cubeDilute(0, sprites0[i]);
						cubeExpand(0, sprites0[i]);
						cubeDilute(0, sprites1[i]);
						cubeExpand(0, sprites1[i]);
						cubeDilute(0, sprites2[i]);
						cubeExpand(0, sprites2[i]);*/

					// Drawing cards.
					//} else 
					if (result <= 0 && i >= handCounts - drawCounts && i < handCounts) {
						cubeAnimate(colorFrameMax + 1, sprites0[i]);
						cubeDilute(1, sprites0[i]);
						cubeExpand(s, sprites0[i]);
						cubeRotate(angle, sprites0[i]);
						cubeMove(sx, sy, sprites0[i]);

						cubeDilute(0, sprites1[i]);
						cubeExpand(0, sprites1[i]);
						cubeDilute(0, sprites2[i]);
						cubeExpand(0, sprites2[i]);

					// Holding/Stable cards.
					} else {


						// Alpha animation.
						var a0 = 0.6, a1 = 1.0;
						if (rolling < 60 && i >= handCounts - newCounts && i < handCounts) {
							a0 = rolling < 30 ? 1 * (1.2 - 0.02 * rolling) : 1 * 0.6;
							a1 = rolling < 60 ? 1 * (-0.2 + 0.02 * rolling) : 1 * 1.0;
						}
						if (i >= handCounts) {
							//a0 = 0.6;
							a1 = 1.0;
						}

						// Colors.
						var n0 = n >= 0 ? cubeDiv(n, numberFrameMax) : colorFrameMax + 2 + n;
						cubeAnimate(n0, sprites0[i]);
						cubeDilute(a0, sprites0[i]);
						cubeExpand(s, sprites0[i]);
						cubeRotate(0, sprites0[i]);					
						cubeMove(sx, sy, sprites0[i]);				

						// No number.
						if (n < 0) {
							cubeDilute(0, sprites1[i]);
							cubeExpand(0, sprites1[i]);
							cubeDilute(0, sprites2[i]);
							cubeExpand(0, sprites2[i]);

						} else {

							// Numbers.
							var n1 = cubeMod(n, numberFrameMax);

							// Number cards.
							if (n0 <= colorFrameMax && n1 >= courtFrameMax) {
								cubeAnimate(n1 - courtFrameMax + frameMin + 9, sprites2[i]);
								cubeDilute(0, sprites1[i]);
								cubeExpand(0, sprites1[i]);
								cubeDilute(a1, sprites2[i]);
								cubeExpand(s, sprites2[i]);

							// Court or Joker original design cards.
							} else if (buffers[1]) {
								cubeAnimate(n1, sprites1[i]);
								cubeDilute(a1, sprites1[i]);
								cubeExpand(s, sprites1[i]);
								cubeDilute(0, sprites2[i]);
								cubeExpand(0, sprites2[i]);

							// Court or Joker cards.
							} else {
								cubeAnimate(n1 + 6, sprites2[i]);
								cubeDilute(0, sprites1[i]);
								cubeExpand(0, sprites1[i]);
								cubeDilute(a1, sprites2[i]);
								cubeExpand(s, sprites2[i]);
							}
						}

						cubeMove(sx, sy, sprites1[i]);
						cubeMove(sx, sy, sprites2[i]);
					}
				}
			}

			// Clear screen.
			cubeClear();

			// Draw sprites.
			for (let i = 0; i < 2; i++) {
				cubeDraw(sprites[i]);
			}
			for (let i = 0; i < handCounts + 2; i++) {
				{

			//for (var y = 0; y < lines; y++) {
			//	for (var x = 0; x < rows[y]; x++) {
			//		var i = lineMax * y + x;

					cubeDraw(sprites0[i]);
					cubeDraw(sprites1[i]);
					cubeDraw(sprites2[i]);
				}
			}

			await cubeWait(10);
		}
	}
})();</script><!--/Main-->
</body>
</html>
