<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<title>Karuta</title>
<link rel="icon" type="image/svg" href="icon.svg">
<link rel="apple-touch-icon" href="icon.png" sizes="192x192">
<script src="manifest.js"></script>
<style>
body {
	font-family: Courier, monospace, sans-serif;
	background-color: #fff;
}
a {
	color: #000;
	text-decoration: none;
}
#container {
	width: 100%; height: 100%;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: flex-start; -webkit-justify-content: flex-start;
	align-items: center; -webkit-align-items: center;
	overflow: hidden;
}
#header {
	width: 95%; margin: 0px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: space-between; -webkit-justify-content: space-between;
	align-items: center; -webkit-align-items: center;
}
#contents {
	position: relative;
	width: 95%; height: 90%;
	flex: 1 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	background-color: #eee;
}
#screens {
	width: 100%; height: 100%;
	flex: 1 1 auto;
	display: grid; display: -webkit-grid;
	background-color: #ddd;
}
#footer {
	width: 95%; margin: 0px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: flex-end; -webkit-justify-content: flex-end;
	align-items: center; -webkit-align-items: center;
}
#author,#version {
	font-size: 12px;
	opacity: 0.06;
}
#logo {
	height: 60px;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: flex-start; -webkit-justify-content: flex-start;
	align-items: center; -webkit-align-items: center;
}
#icon {
	width: 40px; height: 40px; margin-right: 10px;
	background-image: url('resource.svg');
}
#title {
	margin: 0px;
	font-size: 24px;
}
#menu {
	width: 120px; height: 40px;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	opacity: 0.5;
}
#menu a {
	width: 40px; height: 44px;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	color: #000;
	font-size: 30px;
	text-decoration: none;
	transform: scale(1);
	opacity: 1;
}
#menu a:hover {
	transform: scale(1);
	opacity: 0.6;
}
#menu a:active {
	transform: scale(0.9);
	opacity: 1;
}
@media (max-height: 479px) {
	#logo {
		height: 20px;
	}
	#icon {
		margin-left: -12px;
		margin-right: -8px;
		transform: scale(0.4);
	}
	#title {
		font-size: 12px;
	}
	#menu {
		height: 20px;
	}
	#menu a {
		font-size: 12px;
	}
	#author,#version {
		height: 10px;
		font-size: 8px;
	}
}
</style>
</head>
<body>
<div id="container">
	<h1 id="header">
		<a href="?" id="logo">
			<div id="icon"></div>
			<div id="title">Karuta</div>
		</a>
		<div id="menu">
			<a href="javascript:changeCounts(-1);">-</a>
			<a href="javascript:changePattern();">|</a>
			<a href="javascript:changeCounts(+1);">+</a>
		</div>
	</h1>
	<div id="contents" class="cubeScreen"></div>
	<h6 id="footer">
		<div id="author">.</div>
		<div id="version">.</div>
	</h6>
</div>
<script src="cube-api-0.8.js"></script>
<!--Resource!--><script>
	var canvases = [null, null]; // Original design canvas.

	// Query parameters.
	//  McN/S   : M = Hand card maximum, N = Deck card maximum, S = Suit counts.
	//  &r=1234 = Random seed, p
	//  &p=1/3  = Deck sharing identifier.
	//  &n1~n13 = Card face number design.
	//  &f1~f4  = Card face design.
	//  &f5     = Card face dummy/joker design.
	//  &f6     = Card back design.
	//  &c1~c6  = Color palette.
	var keys = cubeParamKeys();

	// BACK:  f21f31f41f51f61f71f81f22f42f62f82f23f33f53f73f83f24f44f64f84f25f35f55f75f85f26f46f66f86f27f37f57f77f87f28f48f68f88f29f39f49f59f69f79f89
	// SPADE: c53c44c54c64c35c45c55c65c75c36c46c56c66c76c47c57c67
	// HEART: a43a63a34a44a54a64a74a35a45a55a65a75a46a56a66a57
	// DIAM:  d53d44d54d64d35d45d55d65d75d46d56d66d57  
	// CLUB:  b43b53b63b44b54b64b35b45b55b65b75b36b46b56b66b76b57
	// JOKER: e33e73e44e54e64e45e55e65e46e56e66e37e77
	// JACK:  f53f63f64f65f46f66f57f67
	// QUEEN: f43f53f63f44f64f45f65f46f56f67
	// KING:  f43f63f44f64f45f55f46f66f47f67
	// COLOR: fff d66 6b6 66d bb4 888 000

	// BACK:  e21081e29089e22028e82088e42e62e33e53e73e44e64e35e55e75e46e66e37e57e77e48e68
	// SPADE: c44067c35076c53054
	// HEART: a44066a34075a43044a63064a56057
	// DIAM:  d44066d53057d35075  
	// CLUB:  b43066b54057b35076
	// JOKER: e33e73e44066e37e77
	// JACK:  f53f63067f46f57
	// QUEEN: f43063f43046f63065f5
	// KING:  f43047f63064f66067f55
	// COLOR: d66 6b6 66d bb4 888 000

	// Example 1: 54 Playing cards including 2-10,J,Q,K,A and Joker.
	// 5c54&f0=g21089&f1=c44067c35076c53054&f2=a44066a34075a43044a63064a56057&f3=d44066d53057d35075&f4=b43066b54057b35076&f5=e21e41e61e81e23e83e25e85e27e87e29e49e69e89&f6=e21081e29089e21029e81089e42e62e33e53e73e44e64e35e55e75e46e66e37e57e77e48e68&n1=f53f44047f64067f56&n2=f43063f64f45065f46f47067&n3=f43063f45065f47067f63067&n4=f43045f45065f63067&n5=f43063f44f45065f66f47067&n6=f43063f43047f45065f66f47067&n7=f43063f44f63067&n8=f43063f43047f55f63067f47067&n9=f43063f43045f45065f64067f47067&n10=f43047f63083f63067f83087f67087&n11=f53f63067f46f57&n12=f43063f43046f63065f56f67&n13=f43047f63064f66067f55&c1=d66&c2=6b6&c3=66d&c4=bb4&c5=888&c6=000&c7=fff

	// Example 2: Dice design cards.
	// 3c54/9&f0=g11099f11091f11018f91098f19099&f1=f55&f2=f73f37&f3=f73f55f37&f4=f33f73f37f77&f5=f33f73f55f37f77&f6=f33f73f35f75f37f77&f7=f33f73f35f55f75f37f77&f8=f33f53f73f35f75f37f57f77&f9=f33f53f73f35f55f75f37f57f77&f10=f11091f11018f91098f19099&f11=f11091f11018f91098f19099e33e73e44e54e64e45e55e65e46e56e66e37e77&n1=c53c44c54c64c35c45c55c65c75c36c46c56c66c76c47c57c67&n2=a43a63a34a44a54a64a74a35a45a55a65a75a46a56a66a57&n3=d53d44d54d64d35d45d55d65d75d46d56d66d57&n4=b43b53b63b44b54b64b35b45b55b65b75b36b46b56b66b76b57&n5=e33e73e44e54e64e45e55e65e46e56e66e37e77&c1=d66&c2=6b6&c3=66d&c4=bb4&c5=888&c6=000&c7=fff

	// Load color palette parameters.
	var palette = [cubeVector(255, 255, 255), cubeVector(0, 0, 0)];
	for (let j = 0; j <= keys.length; j++) {
		let data = cubeParamData("c"+ j);
		if (data.length >= 3) {
			let d = cubeDiv(data.length, 3); // d=1:RGB, d=2:RRGGBB.
			palette[j] = cubeVector(
				data[0 * d] * 16 + data[(0 + 1) * d - 1],
				data[1 * d] * 16 + data[(1 + 1) * d - 1],
				data[2 * d] * 16 + data[(2 + 1) * d - 1]);
		}
	}

	// Load face design parameters.
	let designsMax = [0, 0], designsKeys = ["f", "n"];
	var bufferPixel = 2, bufferWidth = 9, bufferOffset = 1, bufferScale = 2;
	for (let k = 0; k < designsKeys.length; k++) {
		for (let j = 0; j <= keys.length; j++) {
			let data = cubeParamData(designsKeys[k] + j);
			for (let i = 0; i < data.length; i += 3) {
				let x = data[i + 1], y = data[i + 2];
				if (x > bufferWidth || y > bufferWidth) {
					if (x > 16 || y > 16) {
						bufferPixel = 1;
						bufferWidth = 32;
						bufferOffset = 4;
						bufferScale = 1;
					} else if (x > 9 || y > 9) {
						bufferPixel = 1;
						bufferWidth = 16;
						bufferOffset = 2;
						bufferScale = 2;
					}
					while (x > bufferWidth || y > bufferWidth) {
						bufferWidth = bufferWidth * 2;
						bufferOffset = bufferOffset * 2;
						bufferScale = bufferScale / 2;
					}
				}
				if (j > 0) {
					designsMax[k] = j > designsMax[k] ? j : designsMax[k];
				}
			}
		}
	}
	let size = bufferWidth * bufferScale + bufferOffset * 2;
	for (let k = 0; k < designsKeys.length; k++) {
		if (designsMax[k] > 0) {
			canvases[k] = cubeCanvas(size, size, bufferScale, designsMax[k]);
			console.log(":size=" + size.toString() +
				" bufferWidth=" + bufferWidth.toString() +
				" bufferScale=" + bufferScale.toString());
			for (let j = 0; j <= keys.length; j++) {
				let data = cubeParamData(designsKeys[k] + j);
				if (data.length > 0) {
					for (let i = 0; i < data.length; i += 3) {
						let pos = cubeVector(
							(data[i + 1] - 1) + bufferOffset / bufferScale,
							(data[i + 2] - 1) + bufferOffset / bufferScale, 0);

						// Color.
						let c = data[i] >= 10 ? data[i] - 9 : data[i];
						let color = palette[c] ? palette[c] : palette[1];

						// Pixel rect.
						let size = cubeVector(1, 1, 0);

						// Large rect.
						if (i < data.length - 3 && data[i + 3] == 0) {
							size.x = data[i + 4] - data[i + 1] + 1;
							size.y = data[i + 5] - data[i + 2] + 1;
							i += 3;
						}

						// Common data.
						if (j == 0) {
							for (let l = 1; l <= keys.length; l++) {
								cubeCanvasRect(pos, size, color, l - 1, canvases[k]);
							}
						} else {
							cubeCanvasRect(pos, size, color, j - 1, canvases[k]);
						}
					}
				}
			}
		}
	}
</script><!--/Resource-->

<!--Menu--><script>
	//console.log = () => {};
	document.querySelector("#author").innerText = manifest.author + manifest.scope.slice(0, -1);
	document.querySelector("#version").innerText = "#" + manifest.version.substr(-4);
	document.querySelector("#logo").href = window.location.search;

	// Get query parameters.
	var params = cubeParamNumbers(0);
	var counts = 8; // Grid counts.
	var pattern = 0; // Grid pattern. (0:Chess, 1:Goban)
	var handCounts = params[0] > 0 ? params[0] : 5; // Hand card counts.
	var maximum = params[1] >= 0 ? params[1] : 52; // Deck card maximum.
	var colors = params[2] >= 0 ? params[2] : 4; // Card kind counts.
	var original = 0; // Original design icon frame.
	var rolling = 0; // Rolling count.

	// Set counts.
	var setCounts = (x) => {
		counts = (x > 18) ? 18 : (x < 1) ? 1 : x;
		rolling = -1; // Reset.
	};

	// Set pattern.
	var changePattern = () => {
		pattern = pattern > 0 ? 0 : 1;
		rolling = -1; // Reset.
	};

	// Set maximum number.
	var setMaximum = (x) => {
		maximum = (x > 80) ? 80 : (x < 0) ? 0 : x;

		// Reset card icon.
		var icon = document.getElementById("icon");
		if (icon) {
			var iconFrameMax = cubeDiv(maximum, colors);
			if (canvases[0]) {
				icon.style.backgroundImage = "url(\"" + canvases[0].toImage() + "\")";
				original = original + 1 <= iconFrameMax ? original + 1 : 1;
				var nx = -cubeMod(original - 1, iconFrameMax) * 40;
				var ny = -cubeDiv(original - 1, iconFrameMax) * 40;
				icon.style.position = "2 0";
				icon.style.backgroundPosition = "" + nx + " " + ny;
			} else {
				var n = maximum == 52 ? 6 : maximum == 54 ? 5 : maximum == 0 ? 10 :
					maximum < 56 ? cubeDiv(maximum, 4) + 7 : cubeDiv(maximum, 4) + 10;
				var nx = -cubeMod(n - 1, iconFrameMax) * 40;
				var ny = -cubeDiv(n - 1, iconFrameMax) * 40;
				icon.style.position = "0 0";
				icon.style.backgroundPosition = "" + nx + " " + ny;
			}
		}

		rolling = -2; // Restart.
	};

	var changeCounts = (x) => {
		setCounts(counts + x);
	};
	var changeMaximum = () => {
		if (canvases[0]) {
			setMaximum(maximum);
		} else {
			setMaximum(maximum = maximum == 52 ? 54 : maximum == 54 ? 0 : 52);
		}
	};

	// Initialize settings.
	setCounts(counts);
	setMaximum(maximum);
</script><!--/Menu-->

<!--Main--><script>(async()=>{
	//var maximum = 6; // Maximum deck counts.
	//var rolling = 0; // Rolling count.

	var jokers = maximum > 0 ? cubeMod(maximum, colors) : 0; // Joker card kinds.
	var numberMax = maximum > 0 ? cubeDiv(maximum, colors) : 10; // Card maximum number.

	// Resize screen.
	cubeResizeScreen(240, 300);

	var joypad = cubeJoypad();

	// Create count sprites.
	var sprites = [];
	for (var i = 0; i < 2; i++) {
		sprites[i] = await cubeSprite("resource.svg", 40, 40);
	}

	// Create card sprites.
	const cardCountsMax = 54, cardExtraMax = 4, cardExtraHoldable = 2;
	var colorSprites = [], numberSprites = [];
	for (var i = 0; i < cardCountsMax + cardExtraMax; i++) {
		// Color sprites.
		if (canvases[0]) {
			colorSprites[i] = await cubeBufferSprite(canvases[0]);
		} else {
			colorSprites[i] = await cubeSprite("resource.svg", 40, 40);
		}
		// Number sprites.
		if (canvases[1]) {
			numberSprites[i] = await cubeBufferSprite(canvases[1]);
		} else {
			numberSprites[i] = await cubeSprite("resource.svg", 40, 40);
		}
	}

	// Create hand shade sprite.
	var shadeSprite = null;
	{
		let shadeCanvas = cubeCanvas(240, 40, 1);
		const shadeSize = cubeVector(240-4, 240-4);
		const shadeColor = cubeVector(136, 136, 136);
		cubeCanvasRect(cubeVector(2, 2), shadeSize, shadeColor, 0, shadeCanvas);
		shadeSprite = await cubeCanvasSprite(shadeCanvas);
		cubeMove(120, 280, shadeSprite);
	}

	// Board sprite.
	var boardSprite = null, boardGridSize = null;

	// Sprite frame.
	var frameMax = maximum > 0 ? maximum : 10 * colors;
	var frameMin = maximum > 0 ? 1 : 0;
	var colorFrameMax = colors;
	var numberFrameMax = numberMax;
	const frameBlank = colorFrameMax + 1, frameBack = colorFrameMax + 2;

	// Cards.
	var decks = [], trashes = [];
	var handCards = [], playCards = [], holdCards = [];
	const blankCard = { x:0, y:0, angle:0, frame:0, flag:0 };
	const backsidedCard = { x:0, y:0, angle:0, frame:0, flag:1 };
	var drawCounts = 0;

	// Main loop.
	var result = 1;
	while (true) {

		// Load board sprite.
		let boardGridCounts = counts, boardGridPattern = pattern;
		let boardGridType = cubeMod(boardGridCounts, 2) ? boardGridPattern : !boardGridPattern; // 0:-1,0,1 1:-0.5,0.5
		let boardCanvas = cubeCanvas(160 + boardGridPattern * 2, 160 + boardGridPattern * 2, 1);
		let boardGridColor = [cubeVector(238, 238, 238), cubeVector(204, 204, 204)];
		boardGridSize = cubeVector(160 / boardGridCounts, 160 / boardGridCounts);
		if (boardGridPattern > 0) {
			cubeCanvasRect(cubeVector(0, 0), cubeVector(162, 162),
				boardGridColor[1], 0, boardCanvas);
		}
		for (let i = 0; i < boardGridCounts; i++) {
			for (let j = 0; j < boardGridCounts; j++) {
				cubeCanvasRect(
					cubeVector(i*boardGridSize.x+1+boardGridPattern, j*boardGridSize.y+1+boardGridPattern),
					cubeVector(boardGridSize.x-2, boardGridSize.y-2),
					boardGridColor[boardGridPattern>0?0:1], 0, boardCanvas);
			}
		}
		boardSprite = await cubeCanvasSprite(boardCanvas);
		cubeMove(120, 150, boardSprite);

		// Reset and shuffle decks.
		if (rolling < 0) {
			frameMax = maximum > 0 ? maximum : 10 * colors;
			frameMin = maximum > 0 ? 1 : 0;

			console.log("maximum=" + maximum + " frameMax=" + frameMax + " handCounts=" + handCounts +
				" colors=" + colors + " jokers=" + jokers + " numberMax=" + numberMax)

			// Create new decks.
			decks = [], trashes = [], handCards = [], playCards = [], holdCards = [];
			drawCounts = 0;
			for (let j = 0; j < frameMax; j++) {
				decks[j] = cubeClone(backsidedCard);
				decks[j].frame = j + 1;
			}

			// Shuffle by Fisher-Yates argorythm.
			for (let i = decks.length - 1; i > 0; i--) {
				let j = cubeRandom(i + 1);
				let d = decks[i];
				decks[i] = decks[j];
				decks[j] = d;
			}

			// Hand counts.
			//var handCounts = counts;
			// Discard hand cards.
			while (handCounts < handCards.length && handCards.length > 0) {
				trashes.push(handCards.shift());
				drawCounts = 0;
			}
			// Draw initial card from decks.
			while (handCounts > handCards.length && decks.length > 0) {
				let card = decks.pop();
				card.flag = false;
				handCards.push(card);
				drawCounts += 1;
				result = 0;
			}
			handCounts = handCards.length;
		}

		// Sprite scale and angle.
		var angle = 0;

		// Drawing card.
		const rotatingTime = 60;
		let holdingCardId = -1, rotatingCardId = -1;
		for (rolling = 1; rolling >= 1; rolling++) {

			// Screen size.
			var size = cubeScreenSize();

			// Wait for input.
			await cubeReadJoypad(0, joypad);
			let action = cubeJoypadAction(joypad);
			let motion = cubeJoypadMotion(joypad);
			let motionLocalPos = motion ? cubeScreenLocalPos(motion) : null;

			// Check touching each cards.
			let touchingCardId = -1, touchingShadeL = -1, touchingShadeR = -1;
			let touchingBoardPos = null, touchingBoard = -2, touchingShade = -3;
			let touchingDir = 0;//, appending = 0;
			for (let i = handCards.length + playCards.length + cardExtraHoldable - 1; i >= 0; i--) {
				if (cubeCheck(motion, colorSprites[i])) {
					touchingCardId = i;
					break;
				}
			}
			// Check touching hand shade.
			if (touchingCardId < 0 && cubeCheck(motion, shadeSprite)) {
				touchingCardId = touchingShade;
			}
			// Check touching playing board.
			if (touchingCardId < 0 && holdCards.length > 0 && cubeCheck(motion, boardSprite)) {
				touchingCardId = touchingBoard;
			}

			// Touch decks.
			if (touchingCardId == handCards.length + playCards.length + 1 && rotatingCardId < 0) {

				// Not holding.
				if (holdCards.length <= 0) {

					// Empty deck.
					if (decks.length == 0) {
						if (result > 0 && trashes.length > 0) {

							// Recycle trashes to decks and shuffle.
							if (action && action.z < 0 && result > 0) {
								while (trashes.length > 0) {
									let j = cubeRandom(trashes.length);
									let card = trashes.splice(j, 1)[0];
									// Open all cards.
									card.flag = true;
									//card.frame = card.frame < 0 ? -card.frame : card.frame;
									decks.push(card);
								}
								holdingCardId = -1;
								touchingCardId = -1;

							// Start to touch empty deck.
							} else {
								if (holdingCardId < 0 && rotatingCardId < 0) {
									holdingCardId = touchingCardId;
								}

								// Reset for touching animation.
								rolling = 0;
							}
						} else {
							holdingCardId = -1;
							touchingCardId = -1;
						}

					// Draw card from decks.
					} else if (decks.length > 0) {
					
						if (action) {
						//if (motion && rolling > 5) {
							if (action.z < 0 && handCards.length + playCards.length < cardCountsMax) {
								handCounts += 1;
								let card = decks.pop();
								// Open all cards.
								card.flag = false;
								//card.frame = card.frame < 0 ? -card.frame : card.frame;
								handCards.push(card);
								if (result > 0) {
									drawCounts = 1;
								} else {
									drawCounts += 1;
								}
							}
							result = 0;
							holdingCardId = -1;
							touchingCardId = -1;
							rolling = 0;

						// Start to touch decks.
						} else {
							if (holdingCardId < 0 && rotatingCardId < 0) {
								holdingCardId = touchingCardId;
							}

							// Reset for touching animation.
							rolling = 0;
						}
					}
				}
			}

			// Touch trashes.
			if (touchingCardId == handCards.length + playCards.length + 0 && rotatingCardId < 0) {

				if (result > 0) {
					if (action) {

						// Discard to trashes.
						if (holdCards.length > 0) {
							while (holdCards.length > 0) {
								let card = holdCards.pop();
								card.angle = 0;
								//if (card.frame > frameMax) { // Discard as main card.
								//	card.frame -= frameMax;
								//} else if (card.frame < -frameMax) {
								//	card.frame += frameMax;
								//}
								//card.flag = false;
								trashes.push(card);
							}

						// Turn over the card on tapping.
						} else if (action.z < 0 && trashes.length > 0) {
							//trashes[trashes.length-1].frame = -trashes[trashes.length-1].frame;
							trashes[trashes.length-1].flag = !trashes[trashes.length-1].flag;
						}

						holdingCardId = -1;
						touchingCardId = -1;

					// Start to touch trashes.
					} else if (trashes.length > 0) {
						if (holdingCardId < 0 && rotatingCardId < 0) {
							holdingCardId = touchingCardId;
						}
						/*if (motionLocalPos.x < colorSprites[touchingCardId].pos.x - 4) {
							touchingDir = -1;
						} else if (motionLocalPos.x > colorSprites[touchingCardId].pos.x + 4) {
							touchingDir = +1;
						}*/

						// Reset for touching animation.
						rolling = 0;
					}

				} else {
					holdingCardId = -1;
					touchingCardId = -1;
				}
			}

			// Touch hand cards.
			if (0 <= touchingCardId && touchingCardId < handCards.length && rotatingCardId < 0) {
				if (result > 0) {
					let j = touchingCardId;

					// Check touching position.
					if (holdCards.length > 0 && handCards[j].frame != 0) {
						if (motionLocalPos.x <= colorSprites[touchingCardId].pos.x) {
							touchingDir = -1;
						} else {//if (motionLocalPos.x > colorSprites[touchingCardId].pos.x) {
							touchingDir = +1;
						//} else {
						//	appending = 1;
						}
					}

					// Check release action.
					if (action) {

						// Insert hold cards to hand cards.
						if (holdCards.length > 0) {
							let k = touchingDir >= 0 ? j + 1 : j;
							while (holdCards.length > 0) {
								let card = holdCards.pop();
								card.angle = 0;
								//if (appending) { // Add as sub card.
								//	card.frame = card.frame <= frameMax ? card.frame + frameMax : card.frame;
								//} else { // Add as main card.
								//	if (card.frame > frameMax) {
								//		card.frame -= frameMax;
								//	} else if (card.frame < -frameMax) {
								//		card.frame += frameMax;
								//	}
								//}
								//card.flag = false;
								handCards.splice(k, 0, card);
							}
							handCounts = handCards.length;

						// Turn over the hand card on tapping.
						} else if (action.z < 0) {
							handCards[j].flag = !handCards[j].flag;
						}

						holdingCardId = -1;
						touchingCardId = -1;

					// Start to touch hand cards.
					} else {
						if (holdingCardId < 0 && rotatingCardId < 0) {
							holdingCardId = touchingCardId;
						//} else if (touching > 60) {
						//	handCards[j].angle = cubeMod(handCards[j].angle + 90, 360);
						//	touching = 0;
						}

						// Reset for touching animation.
						rolling = 0;
					}

				} else {
					holdingCardId = -1;
					touchingCardId = -1;
				}
			}

			// Touch playing cards.
			if (handCards.length <= touchingCardId && touchingCardId < handCards.length + playCards.length && rotatingCardId < 0) {
				if (result > 0) {
					let j = touchingCardId - handCards.length;

					// Check touching position.
					/*if (holdCards.length > 0 && playCards[j] != 0) {
						if (motionLocalPos.x < colorSprites[touchingCardId].pos.x - 6) {
							touchingDir = -1;
						} else if (motionLocalPos.x > colorSprites[touchingCardId].pos.x + 6) {
							touchingDir = +1;
						//} else {
						//	appending = 1;
						}
					}*/

					// Check release action.
					if (action) {

						// Replace hold cards with play cards.
						if (holdCards.length > 0) {
							//let k = touchingDir >= 0 ? j + 1 : j;
							while (holdCards.length > 0) {
								let card = holdCards.pop();
								/*if (appending) { // Add as sub card.
									card.frame = card.frame <= frameMax ? card.frame + frameMax : card.frame;
								} else { // Add as main card.
									if (card.frame > frameMax) {
										card.frame -= frameMax;
									} else if (card.frame < -frameMax) {
										card.frame += frameMax;
									}
								}*/
								card.x = playCards[j].x;
								card.y = playCards[j].y;

								// Replace and discard to trashes.
								trashes.push(playCards.splice(j, 1, card)[0]);
							}

						// Turn over the playing card on tapping.
						} else if (action.z < 0) {
							playCards[j].flag = !playCards[j].flag;
						}

						holdingCardId = -1;
						touchingCardId = -1;

					// Start to touch playing cards.
					} else {
						if (holdingCardId < 0 && rotatingCardId < 0) {
							holdingCardId = touchingCardId;
							rolling = 0;

						} else if (rolling > rotatingTime && holdCards.length <= 0 && rotatingCardId < 0) {
							holdingCardId = -1;
							rotatingCardId = touchingCardId;
							//playCards[j].angle = cubeMod(playCards[j].angle + 90, 360);
							rolling = 0;

							/*let x = -8, y = -8;
							let ca = cubeCos(playCards[j].angle);
							let sa = cubeSin(playCards[j].angle);

							console.log("a=" + playCards[j].angle +
								" ca=" + ca +
								" sa=" + sa +
								" x*ca-y*sa=" + (x*ca-y*sa) +
								" x*sa+y*ca=" + (x*sa+y*ca));*/
						}

						// Reset for touching animation.
						//rolling = 0;
					}

				} else {
					holdingCardId = -1;
					touchingCardId = -1;
				}
			}

			// Update hand shade grid.
			const shadeGridLineMax = 10;
			let shadeGridLine = handCards.length < shadeGridLineMax ? handCards.length : shadeGridLineMax;
			let shadeGridSize = cubeVector(240 / (shadeGridLine + 1), 40 / (cubeDiv(handCards.length - 1, shadeGridLine) + 1));

			// Touch hand shade.
			if (touchingCardId == touchingShade && rotatingCardId < 0) {
				if (result > 0) {

					// Check touching position.
					/*if (holdCards.length > 0) {
						if (motionLocalPos.x < shadeSprite.pos.x - 6) {
							touchingDir = -1;
						} else if (motionLocalPos.x > shadeSprite.pos.x + 6) {
							touchingDir = +1;
						}
					}*/

					// Check touching position.
					let mod2 = shadeGridSize.x < shadeGridSize.x && cubeMod(handCards.length, 2);
					let x = cubeDiv(motionLocalPos.x - (shadeSprite.pos.x - shadeSprite.size.x/2), shadeGridSize.x);
					let y = cubeDiv(motionLocalPos.y - (shadeSprite.pos.y - shadeSprite.size.y/2), shadeGridSize.y);
					touchingShadeL = x - 1 >= 0 ? x + y * shadeGridLine - 1 : -1;
					touchingShadeR = x + 1 <= shadeGridLine ? x + y * shadeGridLine : -1;

					// Check release action.
					if (action) {

						// Insert hold cards to hand cards.
						if (holdCards.length > 0) {
							//let k = touchingDir >= 0 ? 0 : handCards.length - 1;
							let k = touchingShadeR;
							while (holdCards.length > 0) {
								let card = holdCards.pop();
								card.angle = 0;
								//if (appending) { // Add as sub card.
								//	card.frame = card.frame <= frameMax ? card.frame + frameMax : card.frame;
								//} else { // Add as main card.
								//	if (card.frame > frameMax) {
								//		card.frame -= frameMax;
								//	} else if (card.frame < -frameMax) {
								//		card.frame += frameMax;
								//	}
								//}
								//card.flag = false;
								handCards.splice(k, 0, card);
							}
							handCounts = handCards.length;

						// Turn over all hand cards on tapping.
						} else if (action.z < 0) {
							for (let i = 0; i < handCards.length; i++) {
								handCards[i].flag = !handCards[i].flag;
							}
						}

						holdingCardId = -1;
						touchingCardId = -1;

					// Start to touch all hand cards.
					} else {
						holdingCardId = -1;
						rolling = 0;
					}

				} else {
					holdingCardId = -1;
					touchingCardId = -1;
				}
			}

			// Touch playing board.
			if (touchingCardId == touchingBoard && rotatingCardId < 0) {
				if (result > 0) {
					let j = i - handCards.length;

					// Check touching position.
					if (boardGridType) {
						touchingBoardPos = cubeVector(
							cubeDiv(motionLocalPos.x - boardSprite.pos.x, boardGridSize.x) + 0.5,
							cubeDiv(motionLocalPos.y - boardSprite.pos.y, boardGridSize.y) + 0.5);
					} else {
						touchingBoardPos = cubeVector(
							cubeDiv(motionLocalPos.x - (boardSprite.pos.x - boardGridSize.x/2), boardGridSize.x),
							cubeDiv(motionLocalPos.y - (boardSprite.pos.y - boardGridSize.y/2), boardGridSize.y));
					}

					// Check release action.
					if (action) {

						// Put hold cards to playing board.
						if (holdCards.length > 0) {
							let k = touchingDir >= 0 ? 0 : playCards.length - 1;
							while (holdCards.length > 0) {
								let card = holdCards.pop();
								//if (appending) { // Add as sub card.
								//	card.frame = card.frame <= frameMax ? card.frame + frameMax : card.frame;
								//} else { // Add as main card.
								//	if (card.frame > frameMax) {
								//		card.frame -= frameMax;
								//	} else if (card.frame < -frameMax) {
								//		card.frame += frameMax;
								//	}
								//}
								card.x = touchingBoardPos.x;
								card.y = touchingBoardPos.y;
								//card.flag = false;
								playCards.splice(k, 0, card);
							}
						}

						holdingCardId = -1;
						touchingCardId = -1;

					// Start to touch playing cards.
					} else {
						if (holdingCardId < 0 && rotatingCardId < 0) {
							holdingCardId = touchingCardId;
						}

						// Reset for touching animation.
						//rolling = 0;
					}

				} else {
					holdingCardId = -1;
					touchingCardId = -1;
				}
			}

			// Update hand shade grid.
			shadeGridLine = handCards.length < shadeGridLineMax ? handCards.length : shadeGridLineMax;
			shadeGridSize = cubeVector(240 / (shadeGridLine + 1), 40 / (cubeDiv(handCards.length - 1, shadeGridLine) + 1));

			// On holding.
			if (holdCards.length > 0) {

				// Cancel holding hand cards.
				if (action) {

					// Cancel holding hand cards.
					/*if (holdingCardId < handCards.length) {
						let j = holdingCardId;
						while (holdCards.length > 0) {
							handCards.splice(j, 0, holdCards.pop());
						}
						handCounts = handCards.length;
						holdingCardId = -1;

					// Cancel holding playing cards.
					} else if (holdingCardId < handCards.length + playCards.length) {
						let j = holdingCardId - playCards.length;
						while (holdCards.length > 0) {
							playCards.splice(j, 0, holdCards.pop());
						}
						holdingCardId = -1;

					// Cancel holding cards and discard to trash.
					} else {*/
						while (holdCards.length > 0) {
							let card = holdCards.pop();
							card.angle = 0;
							//if (card.frame > frameMax) { // Discard as main card.
							//	card.frame -= frameMax;
							//} else if (card.frame < -frameMax) {
							//	card.frame += frameMax;
							//}
							//card.flag = false;
							trashes.push(card);
						}
						holdingCardId = -1;
					//}
				}

			// Not holding.
			} else {

				// Remove blank cards.
				/*for (let i = handCards.length - 1; i >= 0; i--) {
					// Remove replaced dummy card.
					if (handCards[i] && handCards[i].frame == 0) {
						handCards.splice(i, 1);
					}
					handCounts = handCards.length;
				}*/
				/*for (let i = handCards.length + playCards.length - 1; i >= 0; i--) {
					// Remove replaced dummy card.
					let j = i - handCards.length;
					if (playCards[j] && playCards[j].frame == 0) {
						playCards.splice(j, 1);
					}
				}*/

				// Start rotating.
				if (rotatingCardId >= 0) {

					// Start to rotate playing cards.
					if (rotatingCardId < handCards.length + playCards.length) {
						let j = rotatingCardId - handCards.length;
						if (motion) {
							if (motionLocalPos.x < colorSprites[rotatingCardId].pos.x - 8) {
								playCards[j].angle = -90;
							} else if (motionLocalPos.x > colorSprites[rotatingCardId].pos.x + 8) {
								playCards[j].angle = 90;
							} else if (motionLocalPos.y < colorSprites[rotatingCardId].pos.y - 8) {
								playCards[j].angle = 0;
							} else if (motionLocalPos.y > colorSprites[rotatingCardId].pos.y + 8) {
								playCards[j].angle = 180;
							}
						} else {
							rotatingCardId = -1;
							touchingCardId = -1;
						}
					} else {
						rotatingCardId = -1;
					}		
				}

				// Start holding.
				if (holdingCardId >= 0 && holdingCardId != touchingCardId) {

					// Start to hold hand cards.
					if (holdingCardId < handCards.length) {
						let j = holdingCardId;
						if (j < handCards.length) {
							if (handCards[j].frame != 0) {
								holdCards.push(handCards.splice(j, 1)[0]);

								// Replace with dummy.
								/*
								holdCards.push(handCards[j]);
								handCards[j] = {
									frame: 0,
									x: handCards[j].x,
									y: handCards[j].y,
									flag: handCards[j].flag};*/
							}
						}

					// Start to hold playing cards.
					} else if (holdingCardId < handCards.length + playCards.length) {
						let j = holdingCardId - handCards.length;
						if (j < playCards.length) {
							if (playCards[j].frame != 0) {
								holdCards.push(playCards.splice(j, 1)[0]);

								// Replace with dummy.
								/*let card = playCards[j];
								holdCards.push(card);
								playCards[j] = cubeClone(blankCard);
								playCards[j].x = card.x;
								playCards[j].y = card.y;*/
							}
						}

					// Start to hold trashes.
					} else if (holdingCardId == handCards.length + playCards.length + 0) {
						if (trashes.length > 0) {
							let j = trashes.length - 1;
							if (trashes[j].frame != 0) {
								holdCards.push(trashes.splice(j, 1)[0]);
							}
						}

					// Start to hold decks.
					} else if (holdingCardId == handCards.length + playCards.length + 1) {
						if (decks.length > 0) {
							let j = decks.length - 1;
							if (decks[j].frame != 0) {
								let card = decks.pop();
								// Hide all cards.
								//card.frame = card.frame > 0 ? -card.frame : card.frame;
								//card.flag = true;
								holdCards.push(card);
							}
						}
					}

					/*// Push blank cards for putting target.
					if (holdCards.length > 0) {
						if (handCards.length > 0) {
							//handCards.unshift(cubeVector(0,0,0));
							//handCards.push(cubeVector(0,0,0));
						} else {
							//handCards.push(cubeVector(0,0,0));
						}
						if (playCards.length > 0) {
							//playCards.unshift(cubeVector(0,0,0));
							//playCards.push(cubeVector(0,0,0));
						} else {
							//playCards.push(cubeVector(0,0,0));
						}
					}*/
				}
			}

			// Roll sprites.
			if (result <= 0) {
				angle = cubeMod(angle + 20, 360);

				// Keep rolling.
				if (motion) {
					rolling = 0;

				// Timeout and show result.
				} else if (rolling > 15) {
					angle = 0;
					result = 1;
					rolling = 1;
					drawCounts = 0;
				}
			}

			// Update sprite animations.
			for (let i = 0; i < handCards.length + playCards.length + cardExtraMax; i++) {
				let n = 0;

				// Update hand cards.
				if (i < handCards.length) {
					let j = i;

					// Holding or within 60f of release.
					//if (holdCards.length > 0 || rolling < 60) {
						// Drawing.
						if (result <= 0 && rolling < 10 && j >= handCards.length - drawCounts) {
							n = -1; // Backside.

						// Showing.
						} else {
							n = handCards[j].flag ? -1 :
								handCards[j].frame;
						}

					// Not holding.
					//} else {
					//	n = -1;
					//}

				// Update playing cards.
				} else if (i < handCards.length + playCards.length) {
					let j = i - handCards.length;
					n = playCards[j].flag ? -1 :
						playCards[j].frame;

				// Update trashes.
				} else if (i == handCards.length + playCards.length + 0) {
					if (trashes.length > 0) {
						n = trashes[trashes.length - 1].flag ? -1 :
							trashes[trashes.length - 1].frame;
					} else {
						n = 0; // Blank.
					}

				// Update decks.
				} else if (i == handCards.length + playCards.length + 1) {
					if (decks.length > 0) {
						n = -1; // Backside.
					} else {
						n = 0; // Blank.
					}

				// Update holding cards.
				} else if (i == handCards.length + playCards.length + 2) {
					if (holdCards.length > 0 && motion) {
						n = holdCards[holdCards.length - 1].flag ? -1 :
							holdCards[holdCards.length - 1].frame;
					} else {
						n = 0; // Blank.
					}

				// Update holding cards shade.
				} else if (i == handCards.length + playCards.length + 3) {
					if (holdCards.length > 0 && motion) {
						n = 0; // Blank.
					} else {
						n = 0; // Blank.
					}
				}

				// Backside cards.
				if (n < 0) {
					cubeAnimate(frameBack, colorSprites[i]);
					cubeAnimate(0, numberSprites[i]);

				// Normal cards.
				} else if (n > 0) {
					let n01 = cubeMod(n - 1, frameMax) + 1;
					let n0 = cubeDiv(n01 - 1, numberFrameMax) + 1; // Colors.
					let n1 = cubeMod(n01 - 1, numberFrameMax) + 1; // Numbers.
					if (!canvases[1]) {
						n1 = n1 + 10;
					}
					cubeAnimate(n0, colorSprites[i]);
					cubeAnimate(n1, numberSprites[i]);

				// Blank cards.
				} else /*if (i < handCards.length + playCards.length + 2)*/ {
					cubeAnimate(frameBlank, colorSprites[i]);
					cubeAnimate(0, numberSprites[i]);

				}
			}

			// Hand card lines and scales.
			//const handLineMax = 18;//frameMax > 7 ? cubeSqrt(handCards.length - 1) + 1 : 7;
			//let handLines = cubeDiv(handCards.length - 1, handLineMax) + 1;
			let handScale = 1;// / ((handCards.length < handLineMax ? handCards.length : handLines >= handLineMax ? handLines : handLineMax) + 2);

			// Play card lines and scales.
			//const playLineMax = 8;//frameMax > 7 ? cubeSqrt(playCards.length - 1) + 1 : 7;
			//let playLines = cubeDiv(playCards.length - 1, playLineMax) + 1;
			let playScale = 0.04 * boardGridSize.y;//(holdCards.length > 0 ? 6 : 5) / ((playCards.length < playLineMax ? playCards.length : playLines >= playLineMax ? playLines : playLineMax) + 2);
			const touchScale = touchingDir == 0 ? 1.2 : 1;

			// Deck/Trash card scales.
			let deckScale = 1;//holdCards.length > 0 ? 1 : 1.5;

			// Grid and center positions.
			let mx = size.x * 1, my = size.y * 1;
			let ox = (size.x - mx) * 0.5, oy = (size.y - my) * 0.5;

			// Set sprite positions.
			for (let i = 0; i < handCards.length + playCards.length + cardExtraMax; i++) {
				let a0 = 0.6, a1 = 1.0, s = 1.0, a = 0, sx = ox, sy = oy; // Default parameters.

				// Set hand card positions.
				if (i < handCards.length) {
					let j = i;
					//let x = cubeMod(j, handLineMax), y = cubeDiv(j, handLineMax);
					//let rows = y < handLines - 1 ? handLineMax : (cubeMod(handCards.length - 1, handLineMax) + 1);
					//const margin = 1;
					//sx = ox + mx * (x + margin + 1) / (rows + margin*2 + 1);
					//sy = oy + my * (y + 11) / (handLines + 12);
					//sy = 260 + 10 * y;// + my * (y + 11) / (handLines + 12);

					// Alpha,Angle animation.
					if (i >= handCards.length - drawCounts) {

						// Drawing.
						if (rolling < 10) {
							a1 = 0;
							a = angle;

						// Showing.
						} else if (rolling < 15) {
							a0 = rolling < 12 ? 1 * (1.2 - 0.05 * rolling) : 1 * 0.6;
							a1 = rolling < 15 ? 1 * (-0.5 + 0.1 * rolling) : 1 * 1.0;
						}
					}

					// Position direct setting.
					let x = cubeMod(j, shadeGridLine);
					let y = cubeDiv(j, shadeGridLine);
					sx = (shadeSprite.pos.x - shadeSprite.size.x/2) + (x + 1) * shadeGridSize.x;
					sy = (shadeSprite.pos.y - shadeSprite.size.y/2 - 30) + (y + 1) * shadeGridSize.y;

					// Touching hand cards scale animation.
					if (touchingCardId == i && rotatingCardId < 0) {
						if (holdCards.length == 0) {
							s = handScale * (rolling < 5 ? (1.2 - 0.04 * rolling) : 1.0);
						} else {
							s = handScale * 1.2;
							sx = sx + 4 * handScale * -touchingDir;
						}

					// Touching hand shade scale animation.
					} else if (touchingCardId == touchingShade && rotatingCardId < 0) {
						if (holdCards.length > 0) {
							if (j == touchingShadeL) {
								s = handScale * 1.2;
								sx = sx - 4 * handScale;
							} else if (j == touchingShadeR) {
								s = handScale * 1.2;
								sx = sx + 4 * handScale;
							}
						} else {
							s = handScale * (rolling < 5 ? (1.2 - 0.04 * rolling) : 1.0);
							//sx = sx + 4 * handScale * -touchingDir;
						}

					// Drawing scale animation.
					} else if (rolling < 5 && i >= handCards.length - drawCounts && rotatingCardId < 0) {
						s = handScale * (0.8 + 0.04 * rolling);

					} else {
						s = handScale;
					}

					/*// Subcard position adjustment.
					if (handCards[j] > frameMax || handCards[j] < -frameMax) {
						if (j > 0 && handCards[j - 1].frame != 0) {
							let adjust = -1;
							for (let k = j - 1; k >= 0; k--) {
								if (-frameMax <= handCards[k].frame && handCards[k].frame <= frameMax) {
									break;
								}
								adjust -= 1;
							}
							sx += mx * 0.08 * adjust;
						}
					}*/

				// Set playing card positions.
				} else if (i < handCards.length + playCards.length) {
					let j = i - handCards.length;
					//let x = cubeMod(j, playLineMax), y = cubeDiv(j, playLineMax);
					//let rows = y < playLines - 1 ? playLineMax : (cubeMod(playCards.length - 1, playLineMax) + 1);
					const margin = 1;
					//sx = ox + mx * (x + margin + 1) / (rows + margin*2 + 1);
					//sy = oy + my * (y + 5 - 0.5 * playScale) / (playLines + 8);

					// Position direct setting.
					sx = boardSprite.pos.x + playCards[j].x * boardGridSize.x;
					sy = boardSprite.pos.y + playCards[j].y * boardGridSize.y;

					// Touching scale animation.
					if (touchingCardId == i && rotatingCardId < 0) {
						s = playScale * touchScale * (rolling < 5 ? (1.2 - 0.04 * rolling) : 1.0)
						//sx = sx + 4 * playScale * -touchingDir;
						//sy = sy + 40 - 40 * touchScale;

					} else {
						s = playScale;
					}

					// Rotating animation.
					if (rotatingCardId == i) {
						a = playCards[j].angle + cubeSin(rolling*10, 20);
					} else {

						// Rotation.
						a = playCards[j].angle;
					}

					/*// Subcard position adjustment.
					if (playCards[j] > frameMax || playCards[j] < -frameMax) {
						if (j > 0 && playCards[j - 1].frame != 0) {
							let adjust = -1;
							for (let k = j - 1; k >= 0; k--) {
								if (-frameMax <= playCards[k].frame && playCards[k].frame <= frameMax) {
									break;
								}
								adjust -= 1;
							}
							sx += mx * 0.08 * adjust;
						}
					}*/

				// Set trash position.
				} else if (i == handCards.length + playCards.length + 0) {
					sx = ox + mx * 1 / 3;
					sy = 25;//oy + my * (0 + 2 * deckScale) / 18;
					if (trashes.length <= 0) {
						a1 = 0;
					}

					// Scale animation.
					if (touchingCardId == i && rotatingCardId < 0) {
						s = deckScale * (rolling < 5 ? (1.2 - 0.04 * rolling) : 1.0);
					} else {
						s = deckScale;
					}

					// Counter.
					let m = trashes.length > 54 ? -1 : trashes.length > 0 ? trashes.length + 10 : 10;
					cubeAnimate(m, sprites[0]);
					cubeDilute(0.2, sprites[0]);
					cubeExpand(0.5, sprites[0]);
					cubeMove(sx, sy + deckScale * 20 + 10, sprites[0]);

				// Set deck position.
				} else if (i == handCards.length + playCards.length + 1) {
					sx = ox + mx * 2 / 3;
					sy = 25;//oy + my * (0 + 2 * deckScale) / 18;
					a1 = 0;

					// Scale animation.
					if (touchingCardId == i && rotatingCardId < 0) {
						s = deckScale * (rolling < 5 ? (1.2 - 0.04 * rolling) : 1.0);
					} else {
						s = deckScale;
					}

					// Counter.
					let m = decks.length > 54 ? -1 : decks.length > 0 ? decks.length + 10 : 10;
					cubeAnimate(m, sprites[1]);
					cubeDilute(0.2, sprites[1]);
					cubeExpand(0.5, sprites[1]);
					cubeMove(sx, sy + deckScale * 20 + 10, sprites[1]);

				// Set holding card position.
				} else if (i == handCards.length + playCards.length + 2) {
					if (holdCards.length > 0 && motion) {
						let localPos = cubeScreenLocalPos(motion);
						sx = localPos.x;
						sy = localPos.y;
						s = playScale * 1.2;

						// Rotation.
						a = holdCards[holdCards.length - 1].angle;

					} else {
						a0 = a1 = 0;
					}

				// Set holding card shade position.
				} else if (i == handCards.length + playCards.length + 3) {
					if (holdCards.length > 0 && touchingBoardPos) {
						// Position direct setting.
						sx = boardSprite.pos.x + touchingBoardPos.x * boardGridSize.x;
						sy = boardSprite.pos.y + touchingBoardPos.y * boardGridSize.y;
						s = playScale;
						a0 = 0.3;
						a1 = 0.5;

						// Rotation.
						a = holdCards[holdCards.length - 1].angle;

					} else {
						a0 = a1 = 0;
					}
				}

				// Update transformations.
				cubeDilute(a0, colorSprites[i]);
				cubeDilute(a1, numberSprites[i]);
				cubeExpand(s, colorSprites[i]);
				cubeExpand(s * 0.5, numberSprites[i]);
				cubeRotate(a, colorSprites[i]);
				cubeRotate(a, numberSprites[i]);
				cubeMove(sx, sy, colorSprites[i]);
				let x = s * -8000, y = s * -8000; // Number position.
				if (a != 0) {
					cubeMove(
						sx + cubeCos(a, x)/1000 - cubeSin(a, y)/1000,
						sy + cubeSin(a, x)/1000 + cubeCos(a, y)/1000,
						numberSprites[i]);
				} else {
					cubeMove(
						sx + x/1000,
						sy + y/1000,
						numberSprites[i]);
				}
			}

			/*if (motion) {
				let v0 = motion;
				let v1 = cubeScreenLocalPos(v0);
				cubeAnimate(1, sprites[1]);
				cubeMove(v1.x, v1.y, sprites[1]);
			}*/

			// Clear screen.
			cubeClear();
			cubeDraw(boardSprite);
			cubeDraw(shadeSprite);

			// Draw sprites.
			for (let i = 0; i < 2; i++) {
				cubeDraw(sprites[i]);
			}
			for (let i = 0; i < handCards.length + playCards.length + cardExtraMax; i++) {
				cubeDraw(colorSprites[i]);
				cubeDraw(numberSprites[i]);
			}

			await cubeWait(10);
		}
	}
})();</script><!--/Main-->
</body>
</html>
