<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<title>Karuta</title>
<link rel="icon" type="image/svg" href="icon.svg">
<link rel="apple-touch-icon" href="icon.png" sizes="192x192">
<script src="manifest.js"></script>
<style>
body {
	font-family: Courier, monospace, sans-serif;
	background-color: #fff;
}
a {
	color: #000;
	text-decoration: none;
}
#container {
	width: 100%; height: 100%;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: flex-start; -webkit-justify-content: flex-start;
	align-items: center; -webkit-align-items: center;
}
#header {
	width: 95%; margin: 0px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: space-between; -webkit-justify-content: space-between;
	align-items: center; -webkit-align-items: center;
}
#contents {
	position: relative;
	width: 95%; height: 90%;
	flex: 1 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	background-color: #eee;
}
#screens {
	width: 100%; height: 100%;
	flex: 1 1 auto;
	display: grid; display: -webkit-grid;
	background-color: #ddd;
}
#footer {
	width: 95%; margin: 0px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: flex-end; -webkit-justify-content: flex-end;
	align-items: center; -webkit-align-items: center;
}
#author,#version {
	font-size: 12px;
	opacity: 0.06;
}
#logo {
	height: 60px;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: flex-start; -webkit-justify-content: flex-start;
	align-items: center; -webkit-align-items: center;
}
#icon {
	width: 40px; height: 40px; margin-right: 10px;
	background-image: url('resource.svg');
}
#title {
	margin: 0px;
	font-size: 24px;
}
#menu {
	width: 120px; height: 40px;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	opacity: 0.5;
}
#menu a {
	width: 40px; height: 44px;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	color: #000;
	font-size: 30px;
	text-decoration: none;
	transform: scale(1);
	opacity: 1;
}
#menu a:hover {
	transform: scale(1);
	opacity: 0.6;
}
#menu a:active {
	transform: scale(0.9);
	opacity: 1;
}
@media (max-height: 479px) {
	#logo {
		height: 20px;
	}
	#icon {
		margin-left: -12px;
		margin-right: -8px;
		transform: scale(0.4);
	}
	#title {
		font-size: 12px;
	}
	#menu {
		height: 20px;
	}
	#menu a {
		font-size: 12px;
	}
	#author,#version {
		height: 10px;
		font-size: 8px;
	}
}
</style>
</head>
<body>
<div id="container">
	<h1 id="header">
		<a href="?" id="logo">
			<div id="icon"></div>
			<div id="title">Karuta</div>
		</a>
		<div id="menu">
			<a href="javascript:changeCounts(-1);">-</a>
			<a href="javascript:changeMaximum();">|</a>
			<a href="javascript:changeCounts(+1);">+</a>
		</div>
	</h1>
	<div id="contents" class="cubeScreen"></div>
	<h6 id="footer">
		<div id="author">.</div>
		<div id="version">.</div>
	</h6>
</div>
<script src="cube-api-0.8.js"></script>
<!--Resource!--><script>
	var buffers = [null, null]; // Original design buffer.

	// Query parameters.
	//  McN/S   : M = Hand card maximum, N = Deck card maximum, S = Suit counts.
	//  &r=1234 = Random seed, p
	//  &p=1/3  = Deck sharing identifier.
	//  &n1~n13 = Card face number design.
	//  &f1~f4  = Card face design.
	//  &f5     = Card face dummy/joker design.
	//  &f6     = Card back design.
	//  &c1~c6  = Color palette.
	var keys = cubeParamKeys();

	// BACK:  f21f31f41f51f61f71f81f22f42f62f82f23f33f53f73f83f24f44f64f84f25f35f55f75f85f26f46f66f86f27f37f57f77f87f28f48f68f88f29f39f49f59f69f79f89
	// SPADE: c53c44c54c64c35c45c55c65c75c36c46c56c66c76c47c57c67
	// HEART: a43a63a34a44a54a64a74a35a45a55a65a75a46a56a66a57
	// DIAM:  d53d44d54d64d35d45d55d65d75d46d56d66d57  
	// CLUB:  b43b53b63b44b54b64b35b45b55b65b75b36b46b56b66b76b57
	// JOKER: e33e73e44e54e64e45e55e65e46e56e66e37e77
	// JACK:  f53f63f64f65f46f66f57f67
	// QUEEN: f43f53f63f44f64f45f65f46f56f67
	// KING:  f43f63f44f64f45f55f46f66f47f67
	// COLOR: fff d66 6b6 66d bb4 888 000


	// BACK:  e21081e29089e22028e82088e42e62e33e53e73e44e64e35e55e75e46e66e37e57e77e48e68
	// SPADE: c44067c35076c53054
	// HEART: a44066a34075a43044a63064a56057
	// DIAM:  d44066d53057d35075  
	// CLUB:  b43066b54057b35076
	// JOKER: e33e73e44066e37e77
	// JACK:  f53f63067f46f57
	// QUEEN: f43063f43046f63065f5
	// KING:  f43047f63064f66067f55
	// COLOR: d66 6b6 66d bb4 888 000

	// Example 1: 54 Playing cards with court cards J,Q,K,A and joker cards.
	// 5c54&f0=g21089&f1=c44067c35076c53054&f2=a44066a34075a43044a63064a56057&f3=d44066d53057d35075&f4=b43066b54057b35076&f5=e21e41e61e81e23e83e25e85e27e87e29e49e69e89&f6=e21081e29089e21029e81089e42e62e33e53e73e44e64e35e55e75e46e66e37e57e77e48e68&n1=f53f44047f64067f56&n2=f43063f64f45065f46f47067&n3=f43063f45065f47067f63067&n4=f43045f45065f63067&n5=f43063f44f45065f66f47067&n6=f43063f43047f45065f66f47067&n7=f43063f44f63067&n8=f43063f43047f55f63067f47067&n9=f43063f43045f45065f64067f47067&n10=f43047f63083f63067f83087f67087&n11=f53f63067f46f57&n12=f43063f43046f63065f56f67&n13=f43047f63064f66067f55&c1=d66&c2=6b6&c3=66d&c4=bb4&c5=888&c6=000&c7=fff

	// Example 2: Dice design cards.
	// 3c54/9&f0=g11099f11091f11018f91098f19099&f1=f55&f2=f73f37&f3=f73f55f37&f4=f33f73f37f77&f5=f33f73f55f37f77&f6=f33f73f35f75f37f77&f7=f33f73f35f55f75f37f77&f8=f33f53f73f35f75f37f57f77&f9=f33f53f73f35f55f75f37f57f77&f10=f11091f11018f91098f19099&f11=f11091f11018f91098f19099e33e73e44e54e64e45e55e65e46e56e66e37e77&n1=c53c44c54c64c35c45c55c65c75c36c46c56c66c76c47c57c67&n2=a43a63a34a44a54a64a74a35a45a55a65a75a46a56a66a57&n3=d53d44d54d64d35d45d55d65d75d46d56d66d57&n4=b43b53b63b44b54b64b35b45b55b65b75b36b46b56b66b76b57&n5=e33e73e44e54e64e45e55e65e46e56e66e37e77&c1=d66&c2=6b6&c3=66d&c4=bb4&c5=888&c6=000&c7=fff

	// Load color palette parameters.
	var depth = 3, palette = [[255,255,255]];
	for (let j = 0; j <= keys.length; j++) {
		let data = cubeParamData("c"+ j);
		if (data.length >= depth) {
			let d = cubeDiv(data.length, depth); // d=1:RGB, d=2:RRGGBB.
			palette[j] = [];
			for (let i = 0; i < depth; i++) {
				palette[j][i] = data[i * d] * 16 + data[(i + 1) * d - 1];
			}
		}
	}

	// Load face design parameters.
	let designsMax = [0, 0], designsKeys = ["f", "n"];
	var bufferPixel = 2, bufferWidth = 9, bufferOffset = 1, bufferScale = 2;
	var designs = [[], []];
	designs[0] = [[[1,1,18,18,255,255,255]]]; // Face side design.
	for (let k = 0; k < designsKeys.length; k++) {
		for (let j = 0; j <= keys.length; j++) {
			let data = cubeParamData(designsKeys[k] + j);
			for (let i = 0; i < data.length; i += 3) {
				let x = data[i + 1], y = data[i + 2];
				if (x > bufferWidth || y > bufferWidth) {
					if (x > 16 || y > 16) {
						bufferPixel = 1;
						bufferWidth = 32;
						bufferOffset = 4;
						bufferScale = 1;
					} else if (x > 9 || y > 9) {
						bufferPixel = 1;
						bufferWidth = 16;
						bufferOffset = 2;
						bufferScale = 2;
					}
					while (x > bufferWidth || y > bufferWidth) {
						bufferWidth = bufferWidth * 2;
						bufferOffset = bufferOffset * 2;
						bufferScale = bufferScale / 2;
					}
					designs[k] = [[[
						bufferOffset,
						bufferOffset,
						bufferWidth + bufferOffset - 1,
						bufferWidth + bufferOffset - 1,
						255, 255, 255]]];
				}
			}
		}
	}
	for (let k = 0; k < designsKeys.length; k++) {
		for (let j = 0; j <= keys.length; j++) {
			let data = cubeParamData(designsKeys[k] + j);
			if (data.length > 0) {
				designs[k][j] = [];
				let w = 2;
				if (j > 0) {
					designsMax[k] = j > designsMax[k] ? j : designsMax[k];
					if (j > 0 && designs[k][0]) {
						let rects = designs[k][0];
						for (let i = 0; i < rects.length; i++) { // designs[0] = Common design.
							designs[k][j].push(rects[i]);
						}
					}
				}
				for (let i = 0; i < data.length; i += 3) {
					let x = (data[i + 1] - 1) * bufferPixel + bufferOffset;
					let y = (data[i + 2] - 1) * bufferPixel + bufferOffset;
					if (x > 0 && y > 0) {
						let color = data[i] >= 10 ? data[i] - 9 : data[i];
						let r = palette[color] ? palette[color][0] : 0;
						let g = palette[color] ? palette[color][1] : 0;
						let b = palette[color] ? palette[color][2] : 0;
						//let rect = [x, y, x + bufferPixel - 1, y + bufferPixel - 1, r, g, b];

						let x2 = data[i + 1] * bufferPixel - 1 + bufferOffset;
						let y2 = data[i + 2] * bufferPixel - 1 + bufferOffset;
						if (i < data.length - 3 && data[i + 3] == 0) {
							x2 = data[i + 4] * bufferPixel - 1 + bufferOffset;
							y2 = data[i + 5] * bufferPixel - 1 + bufferOffset;
							i += 3;
						}
						let rect = [x, y, x2, y2, r, g, b];
						designs[k][j].push(rect);
					}
				}
			}
		}
	}

	// Create pixel buffer for face design.
	let size = bufferWidth * bufferPixel + bufferOffset * 2;
	if (designs[0].length > 1) {
		buffers[0] = cubeBuffer(size, size, bufferScale, designsMax[0]);
		for (let i = 1; i < designs[0].length; i++) {
			if (designs[0][i]) {
				cubeBufferRects(designs[0][i], i - 1, buffers[0]);
			}
		}
	}
	if (designs[1].length > 1) {
		buffers[1] = cubeBuffer(size, size, bufferScale, designsMax[1]);
		for (let i = 1; i < designs[1].length; i++) {
			if (designs[1][i]) {
				cubeBufferRects(designs[1][i], i - 1, buffers[1]);
			}
		}
	}
</script><!--/Resource-->

<!--Menu--><script>
	//console.log = () => {};
	document.querySelector("#author").innerText = manifest.author + manifest.scope.slice(0, -1);
	document.querySelector("#version").innerText = "#" + manifest.version.substr(-4);
	document.querySelector("#logo").href = window.location.search;

	// Get query parameters.
	var params = cubeParamNumbers(0);
	var counts = params[0] > 0 ? params[0] : 5; // Hand card counts.
	var maximum = params[1] >= 0 ? params[1] : 52; // Deck card maximum.
	var colors = params[2] >= 0 ? params[2] : 4; // Card kind counts.
	var original = 0; // Original design icon frame.
	var rolling = 0; // Rolling count.

	// Set counts of cards.
	var setCounts = (x) => {
		counts = (x > 20) ? 20 : (x < 0) ? 0 : x;
		rolling = -1; // Reroll.
	};

	// Set maximum number.
	var setMaximum = (x) => {
		maximum = (x > 80) ? 80 : (x < 0) ? 0 : x;

		// Reset card icon.
		var icon = document.getElementById("icon");
		if (icon) {
			var iconFrameMax = cubeDiv(maximum, colors);
			if (buffers[0]) {
				icon.style.backgroundImage = "url(\"" + buffers[0].toImage() + "\")";
				original = original + 1 <= iconFrameMax ? original + 1 : 1;
				var nx = -cubeMod(original - 1, iconFrameMax) * 40;
				var ny = -cubeDiv(original - 1, iconFrameMax) * 40;
				icon.style.position = "2 0";
				icon.style.backgroundPosition = "" + nx + " " + ny;
			} else {
				var n = maximum == 52 ? 6 : maximum == 54 ? 5 : maximum == 0 ? 10 :
					maximum < 56 ? cubeDiv(maximum, 4) + 7 : cubeDiv(maximum, 4) + 10;
				var nx = -cubeMod(n - 1, iconFrameMax) * 40;
				var ny = -cubeDiv(n - 1, iconFrameMax) * 40;
				icon.style.position = "0 0";
				icon.style.backgroundPosition = "" + nx + " " + ny;
			}
		}

		rolling = -2; // Restart.
	};

	var changeCounts = (x) => {
		setCounts(counts + x);
	};
	var changeMaximum = () => {
		if (buffers[0]) {
			setMaximum(maximum);
		} else {
			setMaximum(maximum = maximum == 52 ? 54 : maximum == 54 ? 0 : 52);
		}
	};

	// Initialize settings.
	setCounts(counts);
	setMaximum(maximum);
</script><!--/Menu-->

<!--Main--><script>(async()=>{
	//var maximum = 6; // Maximum deck counts.
	//var rolling = 0; // Rolling count.

	var courts = buffers[1] ? buffers[1].frames : (maximum > 0 && maximum < 56) ? 3 : 0; // Court card kinds.
	var jokers = maximum > 0 ? cubeMod(maximum, colors) : 0; // Joker card kinds.
	var numberMax = maximum > 0 ? cubeDiv(maximum, colors) : 10; // Card maximum number.

	// Resize screen.
	cubeResizeScreen(240, 300);

	var joypad = cubeJoypad();

	// Create sprites.
	var sprites = [];
	for (var i = 0; i < 2; i++) {
		sprites[i] = await cubeSprite("resource.svg", 40, 40);
	}

	const cardCountsMax = 54, cardExtraMax = 3;
	var colorSprites = [], numberSprites = [];
	for (var i = 0; i < cardCountsMax + cardExtraMax; i++) {
		// Color sprites.
		if (buffers[0]) {
			colorSprites[i] = await cubeBufferSprite(buffers[0]);
		} else {
			colorSprites[i] = await cubeSprite("resource.svg", 40, 40);
		}
		// Number sprites.
		if (buffers[1]) {
			numberSprites[i] = await cubeBufferSprite(buffers[1]);
		} else {
			numberSprites[i] = await cubeSprite("resource.svg", 40, 40);
		}
	}

	// Sprite frame.
	var frameMax = maximum > 0 ? maximum : 10 * colors;
	var frameMin = maximum > 0 ? 1 : 0;
	var colorFrameMax = colors;
	var courtFrameMax = courts;
	var numberFrameMax = numberMax;

	// Card numbers.
	var decks = [], trashes = [];
	var handCards = [], playCards = [], holdCards = [];
	var drawCounts = 0;
	const numberBlankCard = -1;

	// Main loop.
	var result = 1;
	while (true) {

		// Shuffle.
		if (rolling < 0) {
			frameMax = maximum > 0 ? maximum : 10 * colors;
			frameMin = maximum > 0 ? 1 : 0;

			console.log("maximum=" + maximum + " frameMax=" + frameMax + " counts=" + counts +
				" colors=" + colors + " courts=" + courts + " jokers=" + jokers + " numberMax=" + numberMax)

			// Create new decks.
			decks = [], trashes = [], handCards = [], playCards = [], holdCards = [];
			drawCounts = 0;
			for (let j = 0; j < frameMax; j++) {
				decks[j] = frameMax + j;
			}

			// Shuffle by Fisher-Yates argorythm.
			for (let i = decks.length - 1; i > 0; i--) {
				let j = cubeRandom(i + 1);
				let d = decks[i];
				decks[i] = decks[j];
				decks[j] = d;
			}
		}

		// Discard hand cards.
		while (counts < handCards.length && handCards.length > 0) {
			trashes.push(handCards.shift());
			drawCounts = 0;
		}

		// Draw initial card from decks.
		while (counts > handCards.length && decks.length > 0) {
			handCards.push(decks.pop());
			drawCounts += 1;
			result = 0;
		}
		counts = handCards.length;

		// Sprite scale and angle.
		var angle = 0;

		// Drawing card.
		let holdingCardId = -1;
		for (rolling = 1; rolling >= 1; rolling++) {

			// Screen size.
			var size = cubeScreenSize();

			// Wait for input.
			await cubeReadJoypad(0, joypad);
			let action = cubeJoypadAction(joypad);
			let motion = cubeJoypadMotion(joypad);

			// Check each cards.
			let touchingCardId = -1;
			for (let i = handCards.length + playCards.length + cardExtraMax - 1; i >= 0; i--) {
				if (cubeCheck(motion, colorSprites[i])) {

					// Touch hand cards.
					if (i < handCards.length) {

						if (result > 0) {
							if (action) {

								// Insert hold cards to hand cards.
								if (holdCards.length > 0) {
									while (holdCards.length > 0) {
										handCards.splice(i, 0, holdCards.pop());
									}
									counts = handCards.length;
									holdingCardId = -1;

								// Turn over the card on tapping.
								} else {
									handCards[i] = handCards[i] >= frameMax ?
										handCards[i] - frameMax : handCards[i] + frameMax;
									holdingCardId = -1;
								}
								break;

							// Start to touch hand cards.
							} else {
								if (holdingCardId < 0) {
									holdingCardId = i;
								}
								touchingCardId = i;
								rolling = 0;
								break;
							}
						}

					// Touch playing cards.
					} else if (i < handCards.length + playCards.length) {

						if (result > 0) {
							if (action) {
								let j = i - handCards.length;

								// Insert hold cards to play cards.
								if (holdCards.length > 0) {
									while (holdCards.length > 0) {
										playCards.splice(j, 0, holdCards.pop());
									}
									holdingCardId = -1;

								// Turn over the card on tapping.
								} else {
									playCards[j] = playCards[j] >= frameMax ?
										playCards[j] - frameMax : playCards[j] + frameMax;
									holdingCardId = -1;
								}
								break;

							// Start to touch playing cards.
							} else {
								if (holdingCardId < 0) {
									holdingCardId = i;
								}
								touchingCardId = i;

								// Reset for touching animation.
								rolling = 0;
								break;
							}
						}

					// Touch trashes.
					} else if (i == handCards.length + playCards.length + 0) {

						if (result > 0) {
							if (action) {

								// Discard to trashes.
								if (holdCards.length > 0) {
									while (holdCards.length > 0) {
										trashes.push(holdCards.pop());
									}
									holdingCardId = -1;

								// On tapping.
								} else {
									holdingCardId = -1;
								}
								break;

							// Start to touch trashes.
							} else {
								if (holdingCardId < 0) {
									holdingCardId = i;
								}
								touchingCardId = i;

								// Reset for touching animation.
								rolling = 0;
								break;
							}
						}

					// Touch decks.
					} else if (i == handCards.length + playCards.length + 1) {

						// No decks.
						if (decks.length == 0) {
							if (result > 0 && trashes.length > 0) {

								// Recycle trashes to decks and shuffle.
								if (action && result > 0) {
									while (trashes.length > 0) {
										let j = cubeRandom(trashes.length);
										let card = trashes.splice(j, 1)[0];
										// Turn over all cards.
										card = card >= frameMax ? card - frameMax : card;
										decks.push(card);
									}
									holdingCardId = -1;
									break;

								// Start to touch decks.
								} else {
									if (holdingCardId < 0) {
										holdingCardId = i;
									}
									touchingCardId = i;

									// Reset for touching animation.
									rolling = 0;
									break;
								}
							}

						// Draw card from decks.
						} else if (decks.length > 0) {
						
							if (action) {
							//if (motion && rolling > 5) {
								if (handCards.length + playCards.length < cardCountsMax) {
									counts += 1;
									handCards.push(decks.pop());
									if (result > 0) {
										drawCounts = 1;
									} else {
										drawCounts += 1;
									}
								}
								result = 0;
								holdingCardId = -1;
								rolling = 0;
								break;
							} else {
								touchingCardId = i;

								// Reset for touching animation.
								rolling = 0;
								break;
							}
						}
					}
				}
			}

			// On holding.
			if (holdCards.length > 0) {

				// Cancel holding hand cards.
				if (action) {

					// Cancel holding hand cards.
					if (holdingCardId < handCards.length) {
						let j = holdingCardId;
						while (holdCards.length > 0) {
							handCards.splice(j, 0, holdCards.pop());
						}
						counts = handCards.length;
						holdingCardId = -1;

					// Cancel holding playing cards.
					} else if (holdingCardId < handCards.length + playCards.length) {
						let j = holdingCardId - playCards.length;
						while (holdCards.length > 0) {
							playCards.splice(j, 0, holdCards.pop());
						}
						holdingCardId = -1;

					// Cancel holding cards and discard to trash.
					} else {
						while (holdCards.length > 0) {
							trashes.push(holdCards.pop());
						}
						holdingCardId = -1;
					}
				}

			// Not holding.
			} else {

				// Remove blank cards.
				for (let i = handCards.length - 1; i >= 0; i--) {
					if (handCards[i] < 0) {
						handCards.splice(i, 1);
					}
					counts = handCards.length;
				}
				for (let i = handCards.length + playCards.length - 1; i >= 0; i--) {
					let j = i - handCards.length;
					if (playCards[j] < 0) {
						playCards.splice(j, 1);
					}
				}

				// Start holding.
				if (holdingCardId >= 0 && holdingCardId != touchingCardId) {

					// Start to hold hand cards.
					if (holdingCardId < handCards.length) {
						let j = holdingCardId;
						if (handCards[j] >= 0) {
							holdCards.push(handCards[j]);
							handCards[j] = numberBlankCard;
						}

					// Start to hold playing cards.
					} else if (holdingCardId < handCards.length + playCards.length) {
						let j = holdingCardId - handCards.length;
						if (playCards[j] >= 0) {
							holdCards.push(playCards[j]);
							playCards[j] = numberBlankCard;
						}

					// Start to hold trash cards.
					} else if (holdingCardId == handCards.length + playCards.length + 0) {
						let j = trashes.length - 1;
						if (trashes[j] >= 0) {
							holdCards.push(trashes.splice(j, 1)[0]);
						}
					}

					// Push blank cards for putting target.
					if (holdCards.length > 0) {
						if (handCards.length > 0) {
							handCards.unshift(numberBlankCard);
							handCards.push(numberBlankCard);
						} else {
							handCards.push(numberBlankCard);
						}
						if (playCards.length > 0) {
							playCards.unshift(numberBlankCard);
							playCards.push(numberBlankCard);
						} else {
							playCards.push(numberBlankCard);
						}
					}
				}
			}

			// Roll sprites.
			if (result <= 0) {
				angle = cubeMod(angle + 20, 360);

				// Keep rolling.
				if (motion) {
					rolling = 0;

				// Timeout and show result.
				} else if (rolling > 15) {
					angle = 0;
					result = 1;
					rolling = 1;
					drawCounts = 0;
				}
			}

			// Update sprite animations.
			for (let i = 0; i < handCards.length + playCards.length + cardExtraMax; i++) {
				let n = numberBlankCard;

				// Update hand cards.
				if (i < handCards.length) {

					// Drawing.
					if (result <= 0 && rolling < 10 && i >= handCards.length - drawCounts) {
						n = frameMax;

					// Showing.
					} else {
						n = handCards[i];
					}

				// Update playing cards.
				} else if (i < handCards.length + playCards.length) {
					let j = i - handCards.length;
					n = playCards[j];

				// Update trashes.
				} else if (i == handCards.length + playCards.length + 0) {
					if (trashes.length > 0) {
						n = trashes[trashes.length - 1];
					} else {
						n = numberBlankCard;
					}

				// Update decks.
				} else if (i == handCards.length + playCards.length + 1) {
					if (decks.length > 0) {
						n = frameMax;
					} else {
						n = numberBlankCard;
					}

				// Update holding cards.
				} else if (i == handCards.length + playCards.length + 2) {
					if (holdCards.length > 0 && motion) {
						n = holdCards[holdCards.length - 1];
					} else {
						n = numberBlankCard;
					}
				}

				// Update animation frames.
				if (n >= frameMax) {
					cubeAnimate(colorFrameMax + 1, colorSprites[i]);
					cubeAnimate(-1, numberSprites[i]);

				// Normal cards.
				} else if (n >= 0) {
					let n0 = cubeDiv(n, numberFrameMax); // Colors.
					let n1 = cubeMod(n, numberFrameMax); // Numbers.
					if (!buffers[1]) {
						if (n0 <= colorFrameMax && n1 >= courtFrameMax) {
							n1 = n1 - courtFrameMax + frameMin + 9; // Number cards.
						} else {
							n1 = n1 + 6; // Court or Joker cards.
						}
					}
					cubeAnimate(n0, colorSprites[i]);
					cubeAnimate(n1, numberSprites[i]);

				// Blank cards.
				} else if (i < handCards.length + playCards.length + 2) {
					cubeAnimate(colorFrameMax + 0, colorSprites[i]);
					cubeAnimate(-1, numberSprites[i]);

				}
			}

			// Hand card lines and scales.
			const handLineMax = 6;//frameMax > 7 ? cubeSqrt(handCards.length - 1) + 1 : 7;
			let handLines = cubeDiv(handCards.length - 1, handLineMax) + 1;
			let handScale = 1;// / ((handCards.length < handLineMax ? handCards.length : handLines >= handLineMax ? handLines : handLineMax) + 2);

			// Play card lines and scales.
			const playLineMax = 8;//frameMax > 7 ? cubeSqrt(playCards.length - 1) + 1 : 7;
			let playLines = cubeDiv(playCards.length - 1, playLineMax) + 1;
			let playScale = 6 / ((playCards.length < playLineMax ? playCards.length : playLines >= playLineMax ? playLines : playLineMax) + 2);

			// Grid and center positions.
			let mx = size.x * 1, my = size.y * 1;
			let ox = (size.x - mx) * 0.5, oy = (size.y - my) * 0.5;

			// Set sprite positions.
			for (let i = 0; i < handCards.length + playCards.length + cardExtraMax; i++) {
				let a0 = 0.6, a1 = 1.0, s = 1.0, a = 0, sx = ox, sy = oy; // Default parameters.

				// Set hand card positions.
				if (i < handCards.length) {
					let x = cubeMod(i, handLineMax), y = cubeDiv(i, handLineMax);
					let rows = y < handLines - 1 ? handLineMax : (cubeMod(handCards.length - 1, handLineMax) + 1);
					const margin = 0;
					sx = ox + mx * (x + margin + 1) / (rows + margin*2 + 1);
					sy = oy + my * (y + 11) / (handLines + 12);

					// Alpha,Angle animation.
					if (i >= handCards.length - drawCounts) {

						// Drawing.
						if (rolling < 10) {
							a1 = 0;
							a = angle;

						// Showing.
						} else if (rolling < 15) {
							a0 = rolling < 12 ? 1 * (1.2 - 0.05 * rolling) : 1 * 0.6;
							a1 = rolling < 15 ? 1 * (-0.5 + 0.1 * rolling) : 1 * 1.0;
						}
					}

					// Scale animation.
					if (touchingCardId == i) {
						s = handScale * (rolling < 5 ? (1.2 - 0.04 * rolling) : 1.0);
					} else if (rolling < 5 && i >= handCards.length - drawCounts) {
						s = handScale * (0.8 + 0.04 * rolling);
					} else {
						s = handScale;
					}

				// Set playing card positions.
				} else if (i < handCards.length + playCards.length) {
					let j = i - handCards.length;
					let x = cubeMod(j, playLineMax), y = cubeDiv(j, playLineMax);
					let rows = y < playLines - 1 ? playLineMax : (cubeMod(playCards.length - 1, playLineMax) + 1);
					const margin = 1;
					sx = ox + mx * (x + margin + 1) / (rows + margin*2 + 1);
					sy = oy + my * (y + 4) / (playLines + 8);

					// Scale animation.
					if (touchingCardId == i) {
						s = playScale * (rolling < 5 ? (1.2 - 0.04 * rolling) : 1.0);
					} else {
						s = playScale;
					}

				// Set trash positions.
				} else if (i == handCards.length + playCards.length + 0) {
					sx = ox + mx * 1 / 3;
					sy = oy + my * 2 / 18;
					if (trashes.length <= 0) {
						a1 = 0;
					}

					// Scale animation.
					if (touchingCardId == i) {
						s = 1 * (rolling < 5 ? (1.2 - 0.04 * rolling) : 1.0);
					} else {
						s = 1;
					}

					// Counter.
					let m = trashes.length > 54 ? -2 : trashes.length > 0 ? trashes.length + 9 : 9;
					cubeAnimate(m, sprites[0]);
					cubeDilute(0.2, sprites[0]);
					cubeExpand(0.5, sprites[0]);
					cubeMove(sx, sy + 30, sprites[0]);

				// Set deck positions.
				} else if (i == handCards.length + playCards.length + 1) {
					sx = ox + mx * 2 / 3;
					sy = oy + my * 2 / 18;
					a1 = 0;

					// Scale animation.
					if (touchingCardId == i) {
						s = 1 * (rolling < 5 ? (1.2 - 0.04 * rolling) : 1.0);
					} else {
						s = 1;
					}

					// Counter.
					let m = decks.length > 54 ? -2 : decks.length > 0 ? decks.length + 9 : 9;
					cubeAnimate(m, sprites[1]);
					cubeDilute(0.2, sprites[1]);
					cubeExpand(0.5, sprites[1]);
					cubeMove(sx, sy + 30, sprites[1]);

				// Set holding card positions.
				} else if (i == handCards.length + playCards.length + 2) {
					if (holdCards.length > 0 && motion) {
						let localPos = cubeScreenLocalPos(motion);
						sx = localPos.x;
						sy = localPos.y;
					} else {
						a0 = a1 = 0;
					}
				}


				// Update transformations.
				cubeDilute(a0, colorSprites[i]);
				cubeDilute(a1, numberSprites[i]);
				cubeExpand(s, colorSprites[i]);
				cubeExpand(s * 0.5, numberSprites[i]);
				cubeRotate(a, colorSprites[i]);
				cubeRotate(a, numberSprites[i]);
				cubeMove(sx, sy, colorSprites[i]);
				cubeMove(sx - s * 8, sy - s * 8, numberSprites[i]);
			}

			/*if (motion) {
				let v0 = motion;
				let v1 = cubeScreenLocalPos(v0);
				cubeAnimate(1, sprites[1]);
				cubeMove(v1.x, v1.y, sprites[1]);
			}*/

			// Clear screen.
			cubeClear();

			// Draw sprites.
			for (let i = 0; i < 2; i++) {
				cubeDraw(sprites[i]);
			}
			for (let i = 0; i < handCards.length + playCards.length + cardExtraMax; i++) {
				cubeDraw(colorSprites[i]);
				cubeDraw(numberSprites[i]);
			}

			await cubeWait(10);
		}
	}
})();</script><!--/Main-->
</body>
</html>
