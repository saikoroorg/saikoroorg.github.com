<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<title>Goban</title>
<link rel="icon" type="image/svg" href="icon.svg">
<link rel="apple-touch-icon" href="icon.png" sizes="192x192">
<script src="manifest.js"></script>
<style>
body {
	font-family: Courier, monospace, sans-serif;
	background-color: #fff;
}
a {
	color: #000;
	text-decoration: none;
}
#container {
	width: 100%; height: 100%;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: flex-start; -webkit-justify-content: flex-start;
	align-items: center; -webkit-align-items: center;
	overflow: hidden;
}
#header {
	width: 95%; margin: 0px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: space-between; -webkit-justify-content: space-between;
	align-items: center; -webkit-align-items: center;
}
#contents {
	position: relative;
	width: 95%; height: 90%;
	flex: 1 1 auto;
}
.screen {
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
}
.touchScreen {
	position: absolute;
	width: 100%; height: 100%;
	z-index: 100;
}
@media (min-height: 479px) and (max-width: 480px) {
	#screens {
		width: 100%; height: 100%;
		flex: 1 1 auto;
		display: grid; display: -webkit-grid;
		grid-template-columns: 50% 50%;
		background-color: #eee;
	}
	.mainScreen {
		order: 1;
		width: 100%;
		grid-column: span 2;
	}
	.subScreen1 {
		order: 3;
		width: 100%; height: 75%;
	}
	.subScreen2 {
		order: 2;
		width: 100%; height: 75%;
	}
}
@media (max-height: 480px) or (min-width: 479px) {
	#screens {
		width: 100%; height: 100%;
		flex: 1 1 auto;
		display: grid; display: -webkit-grid;
		grid-template-columns: 15% 70% 15%;
		background-color: #eee;
	}
	.mainScreen {
		order: 2;
		width: 100%;
	}
	.subScreen1 {
		order: 3;
		width: 100%;
	}
	.subScreen2 {
		order: 1;
		width: 100%;
	}
}
#footer {
	width: 95%; margin: 0px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: flex-end; -webkit-justify-content: flex-end;
	align-items: center; -webkit-align-items: center;
}
#version {
	font-size: 12px;
	opacity: 0.1;
}
.logo {
	width: 160px; height: 60px; margin: 0px 16px;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: flex-start; -webkit-justify-content: flex-start;
	align-items: center; -webkit-align-items: center;
	font-size: 24px;
}
.logo .icon {
    width: 40px; height: 40px; padding: 10px; margin-left: -28px;
}
.menu {
	width: 120px; height: 40px;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	background-color: #888;
	opacity: 0.9;
}
.menu a {
	width: 40px; height: 40px;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	color: #fff;
	font-size: 30px;
	text-decoration: none;
	transform: scale(1);
	opacity: 1;
}
.menu a:hover {
	transform: scale(1);
	opacity: 0.6;
}
.menu a:active {
	transform: scale(0.8);
	opacity: 1;
}
.menu a #icon {
	width: 40px; height: 40px;
}
</style>
</head>
<body>
<div id="container">
	<h1 id="header">
		<div class="logo">
			<!--img class="icon" src="icon.svg"/!-->
			<a href="?">Goban</a>
		</div>
		<div class="menu">
			<a href="javascript:changeSize(-1);">-</a>
			<a href="javascript:changeType();"><img id="icon" src="icon.svg"/></a>
			<a href="javascript:changeSize(1);">+</a>
		</div>
		<!--div class="menu">
			<a id="x6" href="javascript:setSize(6);">¡Á6</a>
			<a id="x7" href="javascript:setSize(7);">¡Á7</a>
			<a id="x8" href="javascript:setSize(8);">¡Á8</a>
			<a id="x9" href="javascript:setSize(9);">¡Á9</a>
		</div!-->
	</h1>
	<div id="contents">
		<div class="screen touchScreen"></div>
		<div id="screens">
			<div class="screen mainScreen"></div>
			<div class="screen subScreen1"></div>
			<div class="screen subScreen2"></div>
		</div>
	</div>
	<h6 id="footer">
		<div id="version">.</div>
	</h6>
</div>
<script src="cube-api-0.8.js"></script>
<!--Menu--><script>
	//console.log = () => {};
	document.getElementById("version").innerText = manifest.version.substr(-4);

	// Get query parameters.
	var params = cubeParamNumbers("x");
	var gobanSizeMin = 4;
	var gobanSizeMax = params[1] > 9 ? params[1] : 9;
	var gobanSize = params[1] ? params[1] : 6; // Goban lines.
	var gobanType = cubeMod(gobanSize, 2);
	var playing = 0; // Playing count.

	// Set goban type and size.
	var setGoban = (size, type) => {
		gobanType = type > 0 ? 1 : 0;
		size = (size > gobanSizeMax) ? gobanSizeMax : (size < gobanSizeMin) ? gobanSizeMin : size;
		if (gobanType != cubeMod(size, 2)) {
			if (size != gobanSize || gobanType > 0) {
				gobanSize = size + 1 <= gobanSizeMax ? size + 1 : size - 1;
			} else {
				gobanSize = size - 1 >= gobanSizeMin ? size - 1 : size + 1;
			}
		} else {
			gobanSize = size;
		}
       	let icon = document.getElementById("icon");
        if (icon) {
			icon.style.filter = gobanType > 0 ? "invert(75%) brightness(200%)" : "";
			icon.style.scale = gobanType > 0 ? "0.8" : "1";
		}
		playing = -1; // Replay.
	};

	// Change goban size.
	var changeSize = (x=0) => {
		setGoban(gobanSize + x * 2, gobanType);
	};

	// Change goban type.
	var changeType = () => {
		setGoban(gobanSize, gobanType > 0 ? 0 : 1);
	};

	// Initialize settings.
	setGoban(gobanSize, gobanType);
</script><!--/Menu-->
<!--Main--><script>(async()=>{

	// Create screens.
	var touchScreen = cubeScreen("touchScreen");
	var joypad = cubeJoypad(touchScreen);
	const screenWidth = 300;
	const screenHeight = 300;
	var mainScreen = cubeScreen("mainScreen", screenWidth, screenHeight);
	const subScreenWidth = 30;
	const subScreenHeight = 30;
	var subScreens = [], subJoypads = [];
	for (var i = 0; i < 2; i++) {
		subScreens[i] = cubeScreen("subScreen" + (i + 1), subScreenWidth, subScreenHeight);
	}

	// Create sprites.
	var sprite = await cubeSprite("resource.svg", 24, 24);
	var gobans = [], gobansIndex = [], piecesIndex = [];
	for (var i = 0; i < gobanSizeMax * gobanSizeMax; i++) {
		gobans[i] = await cubeSprite("resource.svg", 24, 24);
	}
	const gobansWidth = 240;
	const piecesWidth = 20;
	var gokes = [];
	for (var i = 0; i < 2; i++) {
		gokes[i] = await cubeSprite("resource.svg", 24, 24);
		cubeAnimate((i + 1) * 10 + 5, gokes[i]);
	}
	const gokeWidth = 10;
	var tebanColor = 10;
	const pickIdle = -1, pickNone = -2;
	var pickIndex = pickIdle, pickColor = 0, pickCount = 0;
	var focus = null, focusIndex = -1, focusCount = 0;

	// Main loop.
	while (true) {

		// Initialize pieces.
		for (var i = 0; i < gobanSizeMax * gobanSizeMax; i++) {
			gobansIndex[i] = 0;
			piecesIndex[i] = 0;
		}
		if (gobanType > 0) {
			for (let y = 0; y < gobanSize; y++) {
				let oy = y == 0 ? 1 : y == gobanSize - 1 ? 7 : 4;
				for (let x = 0; x < gobanSize; x++) {
					let ox = x == 0 ? 0 : x == gobanSize - 1 ? 2 : 1;
					gobansIndex[gobanSize*y+x] = ox + oy;
				}
			}
		}
		let scale = gobansWidth / (piecesWidth * (gobanType > 0 ? gobanSize - 1 : gobanSize));
		let piecesWidthScaled = piecesWidth * scale;
		let ox = (screenWidth - gobansWidth) / 2 + (gobanType > 0 ? 0 : piecesWidthScaled / 2);
		let oy = (screenHeight - gobansWidth) / 2 + (gobanType > 0 ? 0 : piecesWidthScaled / 2);

		for (playing = 1; playing >= 1; ) {

			// Read input.
			await cubeReadJoypad(0, joypad);
			let motion = cubeJoypadMotion(joypad);
			let action = cubeJoypadAction(joypad);

			if (motion) {
				let localPos = mainScreen.posToLocalPos(motion);
				let mx = cubeDiv(localPos.x - (ox - piecesWidthScaled / 2), piecesWidthScaled);
				let my = cubeDiv(localPos.y - (oy - piecesWidthScaled / 2), piecesWidthScaled);
				if (my >= 0 && my < gobanSize && mx >= 0 && mx < gobanSize) {
					focus = cubeVector(mx, my);
					focusIndex = gobanSize * my + mx;

					// Check pick a piece.
					if (pickIndex == pickIdle) {

						// Start to pick a piece.
						if (piecesIndex[focusIndex] > 0) {
							pickIndex = focusIndex;

						// Touch gobans.
						} else {
							pickIndex = pickNone;
							pickColor = pickCount = 0;
						}

					// Check hold a piece.
					} else if (pickIndex >= 0 && pickColor == 0) {

						// Start to hold a piece.
						if (focusIndex != pickIndex) {
							pickColor = piecesIndex[pickIndex];
							piecesIndex[pickIndex] = 0;

						// Check timeout.
						} else if (pickCount++ >= 30) {
							pickColor = piecesIndex[pickIndex];
							piecesIndex[pickIndex] = 0;
						}
					}

					// Set touching place.
					cubeDilute(0.5, gobans[focusIndex]);

					// Check release a piece.
					if (action) {
						if (piecesIndex[focusIndex] > 0) {

							// Flip a piece.
							if (pickIndex == focusIndex && pickColor == 0) {
								piecesIndex[focusIndex] = cubeMod(piecesIndex[focusIndex], 20) + 10;
								pickIndex = pickIdle;
								pickColor = pickCount = 0;
								focusIndex = -1;

							// Change a piece.
							} else if (pickIndex >= 0) {
								piecesIndex[pickIndex] = piecesIndex[focusIndex];
								piecesIndex[focusIndex] = pickColor;
								pickIndex = pickIdle;
								pickColor = pickCount = 0;
								focusIndex = -1;

							// Update pick.
							} else {
								piecesIndex[focusIndex] = pickColor;
								pickIndex = pickIdle;
								pickColor = pickCount = 0;
								focusIndex = -1;
							}
						} else {

							// Move a piece.
							if (pickIndex >= 0) {
								piecesIndex[pickIndex] = 0;
								piecesIndex[focusIndex] = pickColor;
								pickIndex = pickIdle;
								pickColor = pickCount = 0;
								focusIndex = -1;

							// Cancel pick.
							} else if (pickIndex == pickNone) {
								piecesIndex[focusIndex] = tebanColor;
								pickIndex = pickIdle;
								pickColor = pickCount = 0;
								focusIndex = -1;

							// Cancel pick.
							} else {
								pickIndex = pickIdle;
								pickColor = pickCount = 0;
								focusIndex = -1;
							}
						}
					}
				} else {

					// Remove a piece.
					if (pickIndex >= 0 && pickColor == 0) {
						piecesIndex[pickIndex] = 0;
					}

					// Cancel pick.
					pickIndex = pickIdle;
					pickColor = pickCount = 0;
					focusIndex = -1;
				}
			}

			// Focus parameters.
			let focusArea = 6, focusScale = 0;
			let focusYmin = 0, focusYmax = 0, focysXmin = 0, focusXmax = 0;
			if (gobanSize >= 6 && focusIndex >= 0) {
				focusCount += 1;
				focusYmin = focus.y - focusArea > 0 ? focus.y - focusArea : 0;
				focusYmax = focus.y + focusArea < gobanSize ? focus.y + focusArea : gobanSize - 1;
				focusXmin = focus.x - focusArea > 0 ? focus.x - focusArea : 0;
				focusXmax = focus.x + focusArea < gobanSize ? focus.x + focusArea : gobanSize - 1;
			} else if (focusCount > 0) {
				focusCount -= 10;
				if (focusCount <= 0) {
					focus = null;
					focusCount = 0;
				}
			}
			if (focusCount >= 30) {
				focusScale = focusCount < 60 ? (focusCount - 30) / 30 : 1;
				if (focusCount >= 60) {
					focusCount = 60;
				}
			}
			let gobansScale = focusScale * (gobanSize / 6);

			// Update gobans.
			for (let y = 0; y < gobanSize; y++) {
				for (let x = 0; x < gobanSize; x++) {
					let gx = ox + piecesWidthScaled * x;
					let gy = oy + piecesWidthScaled * y;
					let index = gobanSize * y + x;
					if (focusScale > 0) {
						let gx2 = (x - focus.x) * piecesWidthScaled * gobansScale;
						let gy2 = (y - focus.y) * piecesWidthScaled * gobansScale;
						cubeAnimate(gobansIndex[index] + piecesIndex[index], gobans[index]);
						cubeExpand(scale * (1 + gobansScale), gobans[index]);
						cubeDilute(1, gobans[index]);
						cubeMove(gx + gx2, gy + gy2, gobans[index]);
					} else {
						cubeAnimate(gobansIndex[index] + piecesIndex[index], gobans[index]);
						cubeExpand(scale * 1, gobans[index]);
						cubeDilute(1, gobans[index]);
						cubeMove(gx, gy, gobans[index]);
					}
				}
			}

			// Update temochi piece.
			if (motion) {
				let localPos = mainScreen.posToLocalPos(motion);
				if (pickColor > 0) {
					cubeAnimate(pickColor + 5, sprite);
					cubeDilute(0.5, sprite);
					cubeExpand(scale * (1.5 + gobansScale), sprite);
					cubeMove(localPos.x, localPos.y, sprite);
				} else if (pickIndex == pickNone) {
					cubeAnimate(tebanColor + 5, sprite);
					cubeDilute(0.5, sprite);
					cubeExpand(scale * (1.5 + gobansScale), sprite);
					cubeMove(localPos.x, localPos.y, sprite);
				}
			}

			// Update gokes.
			for (var i = 0; i < 2; i++) {
				let pos = cubeVector(subScreenWidth / 2, subScreenHeight / 2);
				let scale = 1;

				if (motion) {
					let localPos = subScreens[i].posToLocalPos(motion);
					let mx = localPos.x - subScreenWidth / 2;
					let my = localPos.y - subScreenHeight / 2;
					if (-gokeWidth <= mx && mx <= gokeWidth
					 && -gokeWidth <= my && my <= gokeWidth) {
						//if (action) {
							tebanColor = (i + 1) * 10;
							pickIndex = pickIdle;
							pickColor = pickCount = 0;
						//}
						//if (pickIndex == pickIdle) {
							scale = 0.9;
						//}
					}
				}

				// Update gokes.
				cubeDilute((i + 1) * 10 == tebanColor ? 1 : 0.2, gokes[i]);
				cubeExpand(scale, gokes[i]);
				cubeMove(pos.x, pos.y, gokes[i]);
			}

			// Clear sub screens.
			for (var i = 0; i < 2; i++) {
				cubeClear(subScreens[i]);

				// Draw gokes.
				cubeDraw(gokes[i], subScreens[i]);
			}

			// Clear main screen.
			cubeClear(mainScreen);

			// Draw gobans.
			for (var i = 0; i < gobanSize * gobanSize; i++) {
				cubeDraw(gobans[i], mainScreen);
			}

			// Draw focused gobans.
			if (focusScale > 0) {
				for (let y = focusYmin; y <= focusYmax; y++) {
					for (let x = focusXmin; x <= focusXmax; x++) {
						let index = gobanSize * y + x;
						cubeDraw(gobans[index], mainScreen);
					}
				}
			}

			// Draw temochi piece.
			if (motion) {
				if (pickColor > 0) {
					cubeDraw(sprite, mainScreen);
				} else if (pickIndex == pickNone) {
					cubeDraw(sprite, mainScreen);
				}
			}

			await cubeWait(10);
		}
	}
})();</script><!--/Main-->
</body>
</html>
