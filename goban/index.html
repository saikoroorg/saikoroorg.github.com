<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<title>Goban</title>
<link rel="icon" type="image/svg" href="icon.svg">
<link rel="apple-touch-icon" href="icon.png" sizes="192x192">
<script src="manifest.js"></script>
<style>
body {
	font-family: Courier, monospace, sans-serif;
	background-color: #fff;
}
a {
	color: #000;
	text-decoration: none;
}
#container {
	width: 100%; height: 100%;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: flex-start; -webkit-justify-content: flex-start;
	align-items: center; -webkit-align-items: center;
	overflow: hidden;
}
#header {
	width: 95%; margin: 0px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: space-between; -webkit-justify-content: space-between;
	align-items: center; -webkit-align-items: center;
}
#contents {
	position: relative;
	width: 95%; height: 90%;
	flex: 1 1 auto;
}
.screen {
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
}
.touchScreen {
	position: absolute;
	width: 100%; height: 100%;
	z-index: 100;
}
@media (min-width: 480px) {
	#screens {
		width: 100%; height: 100%;
		flex: 1 1 auto;
		display: grid; display: -webkit-grid;
		grid-template-columns: 20% 60% 20%;
		background-color: #eee;
	}
	.mainScreen {
		order: 2;
		width: 100%;
	}
	.subScreen1 {
		order: 3;
		width: 90%;
		margin: 5%;
	}
	.subScreen2 {
		order: 1;
		width: 90%;
		margin: 5%;
	}
}
@media (max-width: 479px) {
	#screens {
		width: 100%; height: 100%;
		flex: 1 1 auto;
		display: grid; display: -webkit-grid;
		grid-template-columns: 50% 50%;
		background-color: #eee;
	}
	.mainScreen {
		order: 1;
		width: 100%;
		grid-column: span 2;
	}
	.subScreen1 {
		order: 3;
		width: 100%; height: 75%;
	}
	.subScreen2 {
		order: 2;
		width: 100%; height: 75%;
	}
}
#footer {
	width: 95%; margin: 0px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: flex-end; -webkit-justify-content: flex-end;
	align-items: center; -webkit-align-items: center;
}
#version {
	font-size: 12px;
	opacity: 0.1;
}
#logo {
	width: 160px; height: 60px; margin: 0px 16px;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: flex-start; -webkit-justify-content: flex-start;
	align-items: center; -webkit-align-items: center;
	font-size: 24px;
}
#logo .icon {
    width: 40px; height: 40px; padding: 10px; margin-left: -28px;
}
#menu {
	width: 120px; height: 40px;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	opacity: 0.9;
}
#menu a {
	width: 40px; height: 40px;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	color: #888;
	font-size: 30px;
	text-decoration: none;
	transform: scale(1);
	opacity: 1;
}
#menu a:hover {
	transform: scale(1);
	opacity: 0.6;
}
#menu a:active {
	transform: scale(0.8);
	opacity: 1;
}
#menu a #icon {
	width: 40px; height: 40px;
}
@media (max-height: 479px) {
	#logo {
		height: 20px;
		font-size: 18px;
	}
	#menu {
		height: 20px;
	}
	#menu a {
		font-size: 20px;
	}
	#menu a #icon {
		transform: scale(0.4);
	}
	#version {
		height: 10px;
		font-size: 8px;
	}
}
</style>
</head>
<body>
<div id="container">
	<h1 id="header">
		<div id="logo">
			<!--img class="icon" src="icon.svg"/!-->
			<a href="?" id="title">Goban</a>
		</div>
		<div id="menu">
			<a href="javascript:changeSize(-2);">x</a>
			<a href="javascript:changeType();"><img id="icon" src="icon.svg"/></a>
			<a href="javascript:changeSize(+2);">o</a>
		</div>
	</h1>
	<div id="contents">
		<div class="screen touchScreen"></div>
		<div id="screens">
			<div class="screen mainScreen"></div>
			<div class="screen subScreen1"></div>
			<div class="screen subScreen2"></div>
		</div>
	</div>
	<h6 id="footer">
		<div id="version">.</div>
	</h6>
</div>
<script src="cube-api-0.8.js"></script>
<!--Menu--><script>
	console.log = () => {};
	document.getElementById("version").innerText = manifest.version.substr(-4);

	// Title logo.
	var title = document.getElementById("title");
	if (title) {
		title.href = window.location.search;
	}

	// Get query parameters.
	var gobanSizeMin = 5;
	var gobanType = cubeParamValue().substr(0, 1) == "o" ? 0 : 1; // Goban type o=0=Checker/Reversi, x=1=Go.
	var param0 = cubeParamNumbers(0, cubeParamValue().substr(0, 1));
 	var gobanSizeMax = param0[1] > 9 ? param0[1] : 9;
	var gobanSize = param0[1] > 0 ? param0[1] : 9; // Goban show lines.
	var gobanCenterX = cubeDiv(gobanSizeMax, 2); // Goban show center.
	var gobanCenterY = cubeDiv(gobanSizeMax, 2); // Goban show center.
	var placements = []; // Placement pieces.
	for (let i = 0; i < gobanSizeMax; i++) {
		placements[i] = [];
		for (let j = 0; j < gobanSizeMax; j++) {
			placements[i][j] = 0;
		}
	}
	var playing = 0; // Playing count.

	// Set goban type and size.
	var setGoban = (size, type) => {
		gobanType = type > 0 ? 1 : 0;
		gobanSize = (size > gobanSizeMax + gobanType - 1) ? gobanSizeMax + gobanType - 1 :
			(size < gobanSizeMin + gobanType - 1) ? gobanSizeMin + gobanType - 1 : size;
      	let icon = document.getElementById("icon");
        if (icon) {
			icon.style.filter = gobanType == 0 ? "invert(75%) brightness(200%)" : "";
			//icon.style.scale = gobanType > 0 ? "0.8" : "1";
		}
		//for (let i = 0; i < gobanSizeMax * gobanSizeMax; i++) {
		//	placements[i] = 0;
		//}
		playing = -1; // Replay.
	};

	// Change goban size.
	var changeSize = (x=0) => {
		setGoban(gobanSize + x, gobanType);
	};

	// Change goban type.
	var changeType = () => {
		if (gobanType > 0) {
			setGoban(gobanSize - 1, 0);
		} else {
			setGoban(gobanSize + 1, 1);
		}
	};

	// Initialize settings.
	setGoban(gobanSize, gobanType);

</script><!--/Menu-->
<!--Resource--><script>

	// Initialize placement pieces.
	var param1 = cubeParamData(1);
	for (let i = 0; i < param1.length / 3; i++) {
		let x = param1[i * 3 + 1], y = param1[i * 3 + 2];
		if (x > 0 && y > 0) {
			x = x >= 10 ? x - 10 : x - 1;
			y = y >= 10 ? y - 10 : y - 1;
			placements[x][y] = param1[i * 3] >= 10 ? param1[i * 3] - 9 : param1[i * 3];
		}
	}

</script><!--/Resource-->
<!--Main--><script>(async()=>{

	// Create screens.
	var touchScreen = cubeScreen("touchScreen");
	var joypad = cubeJoypad(touchScreen);
	const screenWidth = 280, screenHeight = 280;
	var mainScreen = cubeScreen("mainScreen", screenWidth, screenHeight);
	const subScreenWidth = 30, subScreenHeight = 30;
	const playerCount = 2;
	var subScreens = [], subJoypads = [];
	for (let i = 0; i < playerCount; i++) {
		subScreens[i] = cubeScreen("subScreen" + (i + 1), subScreenWidth, subScreenHeight);
	}

	// Create sprites.
	var handSprite = await cubeSprite("resource.svg", 24, 24);
	var gobanSprites = [];
	for (let i = 0; i < gobanSizeMax * gobanSizeMax; i++) {
		gobanSprites[i] = await cubeSprite("resource.svg", 24, 24);
	}
	const gobanWidth = 220;
	const pieceRawWidth = 20;
	var gokeSprites = [];
	for (let i = 0; i < playerCount; i++) {
		gokeSprites[i] = await cubeSprite("resource.svg", 24, 24);
		cubeAnimate((i + 1) * 10 + 5, gokeSprites[i]);
	}
	const gokeWidth = 10;

	// Main loop.
	while (true) {

		// Initialize status.
		let touchingCount = 0; // Touching piece counter.
		let touchingPiecePos = null; // Touching piece position.
		let touchingColor = -1; // Touching goke color.
		let playerColor = 0; // Active player color. (0:black/1:white)
		let movingGobanPos = null; // Moving goban position.
		let pickedColor = -1; // Picked color from goke.
		let pickedPiecePos = null; // Picked piece position.

		let scale = gobanWidth / (pieceRawWidth * (gobanType > 0 ? gobanSize - 1 : gobanSize));
		let pieceWidth = pieceRawWidth * scale;
		let gobanPos = cubeVector();
		let gobanSize2 = 0;

		for (playing = 1; playing >= 1; ) {

			// Update parameters.
			if (gobanSize2 != cubeDiv(gobanSize, 2)) {
				scale = gobanWidth / (pieceRawWidth * (gobanType > 0 ? gobanSize - 1 : gobanSize));
				pieceWidth = pieceRawWidth * scale;
				gobanPos = cubeVector(
					(screenWidth - gobanWidth) / 2 + (gobanType > 0 ? 0 : pieceWidth / 2),
					(screenHeight - gobanWidth) / 2 + (gobanType > 0 ? 0 : pieceWidth / 2));
			}

			// Read input.
			await cubeReadJoypad(0, joypad);
			let motion = cubeJoypadMotion(joypad);
			let action = cubeJoypadAction(joypad);

			// Parse input.
			let motionPos = motion ? mainScreen.posToLocalPos(motion) : null;
			let motionPiecePos = null;
			if (motion) {

				// Check touching piece index of goban.
				let mx = cubeDiv(motionPos.x - (gobanPos.x - pieceWidth / 2), pieceWidth);
				let my = cubeDiv(motionPos.y - (gobanPos.y - pieceWidth / 2), pieceWidth);
				if (0 <= mx && mx < gobanSize && 0 <= my && my < gobanSize) {
					motionPiecePos = cubeVector(mx + gobanCenterX - gobanSize2, my + gobanCenterY - gobanSize2);
				} else {
					motionPiecePos = null;
				}

				// Check touching piece index of goke.
				touchingColor = -1;
				for (let i = 0; i < playerCount; i++) {
					let localPos = subScreens[i].posToLocalPos(motion);
					let mx = localPos.x - subScreenWidth / 2;
					let my = localPos.y - subScreenHeight / 2;
					if (-gokeWidth <= mx && mx <= gokeWidth && -gokeWidth <= my && my <= gokeWidth) {
						touchingColor = i;
					}
				}
			}

			// Check hold a piece.
			if (pickedPiecePos == null) {

				// Start touching a piece.
				if (touchingPiecePos == null && motionPiecePos != null) {
					touchingPiecePos = motionPiecePos.clone();
					touchingCount = 30;

				// Pick from goke.
				} else if (touchingPiecePos == null && touchingColor >= 0) {
					pickedColor = touchingColor;
					pickedPiecePos = null;
					player = touchingColor + 1;
					playerColor = touchingColor;

				// Touching a piece.
				} else if (motionPiecePos != null && motionPiecePos.eq(touchingPiecePos)) {
					if (touchingCount-- <= 0) {

						// Holding a piece.
						if (touchingPiecePos != null && placements[touchingPiecePos.x][touchingPiecePos.y] > 0) {
							pickedPiecePos = touchingPiecePos.clone();
							touchingPiecePos = null;

						// Reset moving the goban.
						} else {
							touchingPiecePos = null;
							/*gobanSize = gobanSizeMax;
							gobanCenterX = gobanCenterY = cubeDiv(gobanSizeMax, 2);*/
						}
					}

				// Start moving a piece.
				} else if (touchingPiecePos != null && placements[touchingPiecePos.x][touchingPiecePos.y] > 0) {
					pickedPiecePos = touchingPiecePos.clone();
					touchingCount = 0;

				// Start moving the goban.
				} else if (touchingPiecePos != null) {
					movingGobanPos = touchingPiecePos.clone();
					touchingCount = 0;

				// Moving the goban.
				} else if (movingGobanPos != null && motionPiecePos != null) {
					/*let touchingX = cubeMod(-touchingIndex - 1, gobanSize) + gobanCenterX - gobanSize2;
					let touchingY = cubeDiv(-touchingIndex - 1, gobanSize) + gobanCenterY - gobanSize2;
					let motionX = cubeMod(motionIndex - 1, gobanSize) + gobanCenterX - gobanSize2;
					let motionY = cubeDiv(motionIndex - 1, gobanSize) + gobanCenterY - gobanSize2;
					let movingX = touchingX - motionX;
					let movingY = touchingY - motionY;
					gobanCenterX = gobanCenterX + movingX;
			       	gobanCenterY = gobanCenterY + movingY;
			       	touchingIndex = -motionIndex;*/
					touchingIndex = 0;
					touchingCount = 0;

				}
			}

			// Update on release.
			if (action) {

				// Check release a piece.
				if (motionPiecePos != null) {
					if (placements[motionPiecePos.x][motionPiecePos.y] > 0) {

						// Flip a piece.
						if (touchingPiecePos.eq(motionPiecePos)) {
							placements[motionPiecePos.x][motionPiecePos.y] = cubeMod(placements[motionPiecePos.x][motionPiecePos.y], 2) + 1;
							touchingPiecePos = null;

						// Change a piece.
						} else if (pickedPiecePos != null) {
							let pieceFrame = placements[motionPiecePos.x][motionPiecePos.y];
							placements[motionPiecePos.x][motionPiecePos.y] = placements[pickedPiecePos.x][pickedPiecePos.y];
							placements[pickedPiecePos.x][pickedPiecePos.y] = pieceFrame;
							touchingPiecePos = pickedPiecePos = null;

						// Overwrite by new piece.
						} else if (touchingPiecePos != null) {
							placements[motionPiecePos.x][motionPiecePos.y] = playerColor + 1;
							//player = cubeMod(player, 2) + 1;
							touchingPiecePos = null;
						}
					} else {

						// Move a piece / Cancel pick.
						if (pickedPiecePos != null) {
							placements[motionPiecePos.x][motionPiecePos.y] = placements[pickedPiecePos.x][pickedPiecePos.y];
							placements[pickedPiecePos.x][pickedPiecePos.y] = 0;
							touchingPiecePos = pickedPiecePos = null;

						// Put a new piece.
						} else if (touchingPiecePos != null) {
							placements[motionPiecePos.x][motionPiecePos.y] = playerColor + 1;
							//player = cubeMod(player, 2) + 1;
							touchingPiecePos = null;
						}
					}
				}

				// Check release out of a board.
				if (motionPiecePos == null) {

					// Remove a piece.
					if (pickedPiecePos != null) {
						placements[pickedPiecePos.x][pickedPiecePos.y] = 0;
						pickedPiecePos = null;
						touchingPiecePos = null;
					}
				}

				touchingColor = -1;
				touchingGoban = -1;
				touchingCount = 0;
				pickedColor = -1;
			}

			// Update parameters.
			if (gobanSize2 != cubeDiv(gobanSize, 2)) {
				gobanSize2 = cubeDiv(gobanSize, 2);
				gobanCenterX = gobanCenterX < gobanSize2 ? gobanSize2 :
					gobanCenterX > gobanSizeMax - gobanSize2 - 1 ? gobanSizeMax - gobanSize2 - 1 :
					gobanCenterX;
		       	gobanCenterY = gobanCenterY < gobanSize2 ? gobanSize2 :
					gobanCenterY > gobanSizeMax - gobanSize2 - 1 ? gobanSizeMax - gobanSize2 - 1 :
					gobanCenterY;
			}

			// Update goban.
			for (let i = 0; i < gobanSize * gobanSize; i++) {
				let x = cubeMod(i, gobanSize) + gobanCenterX - gobanSize2;
				let y = cubeDiv(i, gobanSize) + gobanCenterY - gobanSize2;
				if (x < 0 || y < 0 || x >= gobanSizeMax || y >= gobanSizeMax) {
					console.log("error:" + x + "," + y);
					break;
				}

				// Shift animation frame for Go style.
				let f = gobanType > 0 ?
						((y == 0 ? 1 : y == 0 + gobanSizeMax - 1 ? 7 : 4) +
						 (x == 0 ? 0 : x == 0 + gobanSizeMax - 1 ? 2 : 1)) : 0;

				// Moving/Swapping source.
				if (pickedPiecePos != null && x == pickedPiecePos.x && y == pickedPiecePos.y) {

					// Holding.
					if (pickedPiecePos.eq(motionPiecePos)) {
						cubeExpand(scale * 0.8, gobanSprites[i]);
						cubeDilute(0.2, gobanSprites[i]);
						cubeAnimate(placements[x][y] * 10 + f, gobanSprites[i]);

					// Swapping from. (*motionIndex > 0)
					} else if (motionPiecePos != null && placements[motionPiecePos.x][motionPiecePos.y] > 0) {
						cubeExpand(scale * 0.9, gobanSprites[i]);
						cubeDilute(0.6, gobanSprites[i]);
						cubeAnimate(placements[motionPiecePos.x][motionPiecePos.y] * 10 + f, gobanSprites[i]);

					// Moving from.
					} else {
						cubeExpand(scale * 0.8, gobanSprites[i]);
						cubeDilute(0.1, gobanSprites[i]);
						cubeAnimate(placements[x][y] * 10 + f, gobanSprites[i]);
					}
					cubeMove(gobanPos.x + pieceWidth * cubeMod(i, gobanSize),
						gobanPos.y + pieceWidth * cubeDiv(i, gobanSize), gobanSprites[i]);

				// Touch target.
				} else if (motionPiecePos != null && x == motionPiecePos.x && y == motionPiecePos.y) {

					// Swapping to. (*motionIndex > 0)
					if (motionPiecePos != null && placements[motionPiecePos.x][motionPiecePos.y] > 0 &&
						pickedPiecePos != null && motionPiecePos.ne(pickedPiecePos)) {
						cubeExpand(scale * 0.9, gobanSprites[i]);
						cubeDilute(0.2, gobanSprites[i]);
						cubeAnimate(placements[pickedPiecePos.x][pickedPiecePos.y] * 10 + f, gobanSprites[i]);

					// Moving a picked piece to.
					} else if (pickedPiecePos != null) {
						cubeExpand(scale * 0.9, gobanSprites[i]);
						cubeDilute(0.2, gobanSprites[i]);
						cubeAnimate(placements[x][y] * 10 + f, gobanSprites[i]);

					// Moving from goke to.
					} else if (pickedColor >= 0) {
						cubeExpand(scale * 0.9, gobanSprites[i]);
						cubeDilute(0.2, gobanSprites[i]);
						cubeAnimate(placements[x][y] * 10 + f, gobanSprites[i]);

					// Flipping a piece. (*motionIndex > 0)
					} else if (motionPiecePos != null && placements[motionPiecePos.x][motionPiecePos.y] > 0 && touchingPiecePos != null) {
						cubeExpand(scale * 0.9, gobanSprites[i]);
						cubeDilute(0.4, gobanSprites[i]);
						cubeAnimate(placements[motionPiecePos.x][motionPiecePos.y] * 10 + f, gobanSprites[i]);

					// Putting a new piece.
					} else if (touchingPiecePos != null) {
						cubeExpand(scale * 0.9, gobanSprites[i]);
						cubeDilute(0.1, gobanSprites[i]);
						cubeAnimate((playerColor + 1) * 10 + f, gobanSprites[i]);

					// Idling.
					} else {
						cubeExpand(scale * 1, gobanSprites[i]);
						cubeDilute(1, gobanSprites[i]);
						cubeAnimate(placements[x][y] * 10 + f, gobanSprites[i]);
					}
					cubeMove(gobanPos.x + pieceWidth * cubeMod(i, gobanSize),
						gobanPos.y + pieceWidth * cubeDiv(i, gobanSize), gobanSprites[i]);

				// Stable place.
				} else {
					cubeExpand(scale * 1, gobanSprites[i]);
					cubeDilute(1, gobanSprites[i]);
					cubeAnimate(placements[x][y] * 10 + f, gobanSprites[i]);
					cubeMove(gobanPos.x + pieceWidth * cubeMod(i, gobanSize),
						gobanPos.y + pieceWidth * cubeDiv(i, gobanSize), gobanSprites[i]);
				}
			}

			// Update hand piece.
			{

				// Moving a picked piece.
				if (pickedPiecePos != null) {
					cubeAnimate(placements[pickedPiecePos.x][pickedPiecePos.y] * 10 + 5, handSprite);
					cubeDilute(0.6, handSprite);
					cubeExpand(scale * 1.5, handSprite);
					cubeMove(motionPos.x, motionPos.y, handSprite);

				// Moving from goke.
				} else if (pickedColor >= 0) {
					cubeAnimate(player * 10 + 5, handSprite);
					cubeDilute(0.6, handSprite);
					cubeExpand(scale * 1.5, handSprite);
					cubeMove(motionPos.x, motionPos.y, handSprite);

				// Moving the goban.
				} else if (touchingColor >= 0) {
					cubeAnimate(5, handSprite);
					cubeDilute(0.1, handSprite);
					cubeExpand(scale * 1.5, handSprite);
					cubeMove(motionPos.x, motionPos.y, handSprite);
				}
			}

			// Update goke.
			for (let i = 0; i < playerCount; i++) {

				// Moving to goke.
				if (touchingColor == i && pickedPiecePos != null) {
					cubeExpand(1.2, gokeSprites[i]);
					cubeDilute(playerColor == i ? 1 : 0.2, gokeSprites[i]);

				// Touching goke.
				} else if (touchingColor == i && touchingPiecePos != null) {
					cubeExpand(0.9, gokeSprites[i]);
					cubeDilute(playerColor == i ? 1 : 0.2, gokeSprites[i]);

				// Moving from goke.
				} else if (pickedColor == i) {
					cubeExpand(0.8, gokeSprites[i]);
					cubeDilute(0.6, gokeSprites[i]);

				// Putting new piece from goke.
				} else if (touchingPiecePos != null && placements[touchingPiecePos.x][touchingPiecePos.y] == 0 && playerColor == i) {
					cubeExpand(1.2, gokeSprites[i]);
					cubeDilute(1, gokeSprites[i]);

				// Stable goke.
				} else {
					cubeExpand(1, gokeSprites[i]);
					cubeDilute(playerColor == i ? 1 : 0.2, gokeSprites[i]);
				}
				cubeMove(subScreenWidth / 2, subScreenHeight / 2, gokeSprites[i]);
			}

			// Draw screens
			for (let i = 0; i < playerCount; i++) {
				cubeClear(subScreens[i]);
				cubeDraw(gokeSprites[i], subScreens[i]); // Goke.
			}
			cubeClear(mainScreen);
			for (let i = 0; i < gobanSize * gobanSize; i++) {
				cubeDraw(gobanSprites[i], mainScreen); // Goban.
			}
			if (pickedPiecePos != null || pickedColor >= 0) {
				cubeDraw(handSprite, mainScreen); // Hand piece.
			}

			await cubeWait(10);
		}
	}
})();</script><!--/Main-->
</body>
</html>
