<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<title>Sai</title>
<link rel="icon" type="image/svg" href="icon.svg">
<link rel="apple-touch-icon" href="icon.png" sizes="192x192">
<script src="manifest.js"></script>
<style>
body {
	font-family: Courier, monospace, sans-serif;
	background-color: #fff;
}
a {
	color: #000;
	text-decoration: none;
}
#container {
	//position: absolute;
	//left: 0; top: 0;
	width: 100%; height: 100%;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: flex-start; -webkit-justify-content: flex-start;
	align-items: center; -webkit-align-items: center;
	overflow: hidden;
}
#header {
	width: 95%; margin: 0px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: space-between; -webkit-justify-content: space-between;
	align-items: center; -webkit-align-items: center;
}
#contents {
	position: relative;
	width: 95%; height: 90%;
	flex: 1 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	background-color: #eee;
}
#screens {
	width: 100%; height: 100%;
	flex: 1 1 auto;
	display: grid; display: -webkit-grid;
	background-color: #ddd;
}
#footer {
	width: 95%; margin: 0px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: flex-end; -webkit-justify-content: flex-end;
	align-items: center; -webkit-align-items: center;
}
#author,#version {
	font-size: 12px;
	opacity: 0.06;
}
#logo {
	height: 60px;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: flex-start; -webkit-justify-content: flex-start;
	align-items: center; -webkit-align-items: center;
}
#logo span:hover {
	transform: scale(1);
	opacity: 0.6;
	cursor: pointer;
}
#logo span:active {
	transform: scale(0.9);
	opacity: 1;
}
#icon {
	width: 40px; height: 40px; margin-right: 10px;
	/*background-image: url('resource.svg');*/
}
#title {
	margin: 0px;
	font-size: 24px;
}
#menu {
	width: 120px; height: 40px;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	opacity: 0.5;
}
#menu span {
	width: 40px; height: 44px;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	color: #000;
	font-size: 30px;
	text-decoration: none;
	transform: scale(1);
	opacity: 1;
}
#menu span:hover {
	transform: scale(1);
	opacity: 0.6;
	cursor: pointer;
}
#menu span:active {
	transform: scale(0.9);
	opacity: 1;
}
@media (max-height: 479px) {
	#logo {
		height: 20px;
	}
	#icon {
		margin-left: -12px;
		margin-right: -8px;
		transform: scale(0.4);
	}
	#title {
		font-size: 12px;
	}
	#menu {
		height: 20px;
	}
	#menu span {
		font-size: 12px;
	}
	#author,#version {
		height: 10px;
		font-size: 8px;
	}
}
</style>
</head>
<body>
<div id="container">
	<h1 id="header">
		<a href="?" id="logo">
			<img id="icon" src="icon.svg"/>
			<span id="title" href="#" onclick="javascript:window.top.location.reload();">Sai</span>
		</a>
		<div id="menu">
			<span href="#" onclick="javascript:changeCounts(-1);">-</span>
			<span href="#" onclick="javascript:changeMaximum();">|</span>
			<span href="#" onclick="javascript:changeCounts(+1);">+</span>
		</div>
	</h1>
	<div id="contents" class="cubeScreen"></div>
	<h6 id="footer">
		<div id="author">.</div>
		<div id="version">.</div>
	</h6>
</div>
<script src="cube-api-0.8.js"></script>
<!--Resource--><script>
	var buffer = null; // Original design buffer.


    // Example 1: Standard dotted dice with color pips (1~6) and playing card suit marks (7~12).
    // var query = "2d6&n0=f11099g22088&n1=a55&n2=b73b37&n3=c73c55c37&n4=d33d73d37d77&n5=e33e73e55e37e77&n6=f33f73f35f75f37f77&n7=c44067c35076c53054&n8=a44066a34075a43044a63064a56057&n9=d44066d53057d35075&n10=b43066b54057b35076&n11=e33e73e44066e37e77&n12=g44066&c1=d66&c2=6b6&c3=66d&c4=bb4&c5=888&c6=000&c7=fff"

    // Example 2: Highreso number dice.
    // var query = "2d10&n0=f110ggg220ff&n1=f53057&n2=f43063f64f45065f46f47067&n3=f43063f45065f47067f63067&n4=f43045f45065f63067&n5=f43063f44f45065f66f47067&n6=f43063f43047f45065f66f47067&n7=f43063f44f63067&n8=f43063f43047f55f63067f47067&n9=f43063f43045f45065f64067f47067&n10=f43063f43047f63067f47067&c1=d66&c2=6b6&c3=66d&c4=bb4&c5=888&c6=000&c7=fff"

    // Example 3: Unkoro.
    // var query = "5d6&n1=b44066b34075b43044b63064b56057&n2=a34074a63067a37a46a55&n3=a34074a74076a47067a35a53&n4=a35075a43063a53056a47&n5=a33043a37057a66a74075&n6=a33073a37077a73077&c1=000&c2=d66";
    // cubeLoadParam(null, query);
    // console.log("Query:" + query);

    // Load query parameters.
    //  McN  : M = Roll dice counts, N = Dice maximum number.
    //  &n1~ = Dice face design.
    //  &c1~ = Color palette.
    var keys = cubeParamKeys();

	// Load color palette parameters.
	var depth = 3, palette = [[255,255,255]];
	for (let j = 0; j <= keys.length; j++) {
		let data = cubeParamData("c"+ j);
		if (data.length >= depth) {
			let d = cubeDiv(data.length, depth); // d=1:RGB, d=2:RRGGBB.
			palette[j] = [];
			for (let i = 0; i < depth; i++) {
				palette[j][i] = data[i * d] * 16 + data[(i + 1) * d - 1];
			}
		}
	}

	// Load face design parameters.
	//var bufferParams = [[9,2,1,2], [16,1,2,2], [32,1,4,1]]; // [width,pixel,offset,scale]
	var bufferPixel = 2, bufferWidth = 9, bufferOffset = 1, bufferScale = 2;
	var designs = [[[1,1,18,18,255,255,255]]];
	for (let j = 0; j <= keys.length; j++) {
		let data = cubeParamData("n" + j);
		for (let i = 0; i < data.length; i += 3) {
			let x = data[i + 1], y = data[i + 2];
			if (x > bufferWidth || y > bufferWidth) {
				if (x > 16 || y > 16) {
					bufferPixel = 1;
					bufferWidth = 32;
					bufferOffset = 4;
					bufferScale = 1;
				} else if (x > 9 || y > 9) {
					bufferPixel = 1;
					bufferWidth = 16;
					bufferOffset = 2;
					bufferScale = 2;
				}
				while (x > bufferWidth || y > bufferWidth) {
					bufferWidth = bufferWidth * 2;
					bufferOffset = bufferOffset * 2;
					bufferScale = bufferScale / 2;
				}
				designs = [[[
					bufferOffset,
					bufferOffset,
					bufferWidth + bufferOffset - 1,
					bufferWidth + bufferOffset - 1,
					255, 255, 255]]];
			}
		}
	}
	for (let j = 0; j <= keys.length; j++) {
		let data = cubeParamData("n" + j);
		if (data.length > 0) {
			designs[j] = [];
			if (j > 0 && designs[0]) {
				let rects = designs[0];
				for (let i = 0; i < rects.length; i++) { // designs[0] = Common design.
					designs[j].push(rects[i]);
				}
			}
			for (let i = 0; i < data.length; i += 3) {
				let x = (data[i + 1] - 1) * bufferPixel + bufferOffset;
				let y = (data[i + 2] - 1) * bufferPixel + bufferOffset;
				if (x > 0 && y > 0) {
					let color = data[i] >= 10 ? data[i] - 9 : data[i];
					let r = palette[color] ? palette[color][0] : 0;
					let g = palette[color] ? palette[color][1] : 0;
					let b = palette[color] ? palette[color][2] : 0;
					let x2 = data[i + 1] * bufferPixel - 1 + bufferOffset;
					let y2 = data[i + 2] * bufferPixel - 1 + bufferOffset;
					if (i < data.length - 3 && data[i + 3] == 0) {
						x2 = data[i + 4] * bufferPixel - 1 + bufferOffset;
						y2 = data[i + 5] * bufferPixel - 1 + bufferOffset;
						i += 3;
					}
					let rect = [x, y, x2, y2, r, g, b];
					designs[j].push(rect);
				}
			}
		}
	}

	// Create pixel buffer for face designs.
	if (designs.length > 1) {
		let size = bufferWidth * bufferPixel + bufferOffset * 2;
		buffer = cubeBuffer(size, size, bufferScale, designs.length - 1);
		for (let i = 1; i < designs.length; i++) {
			cubeBufferRects(designs[i], i - 1, buffer);
		}
	}
</script><!--/Resource-->

<!--Menu--><script>
	//console.log = () => {};
	document.querySelector("#author").innerText = manifest.author + manifest.scope.slice(0, -1);
	document.querySelector("#version").innerText = "#" + manifest.version.substr(-4);
	document.querySelector("#logo").href = window.location.search;

	// Get query parameters.
	var params = cubeParamNumbers(0);
	var counts = params[0] > 0 ? params[0] : 1; // Counts of dice.
	var maximum = params[1] >= 0 ? params[1] : 6; // Maximum number of dice face.
	var original = 0; // Original design icon frame.
	var rolling = 0; // Rolling count.

	// Set counts of dice.
	var setCounts = (x) => {
		counts = (x > 20) ? 20 : (x < 1) ? 1 : x;
		rolling = -1; // Reroll.
	};

	// Set maximum number.
	var setMaximum = (x) => {
		maximum = (x > 20) ? 20 : (x < 0) ? 0 : x;

		// Reset dice icon.
		var icon = document.getElementById("icon");
		if (icon) {
			if (buffer) {
				icon.style.backgroundImage = "url(\"" + buffer.toImage() + "\")";
				original = original + 1 <= maximum ? original + 1 : 1;
				var nx = -cubeMod(original - 1, maximum) * 40;
				var ny = -cubeDiv(original - 1, maximum) * 40;
				icon.style.backgroundPosition = "" + nx + " " + ny;
			} else {
				var n = maximum == 0 ? 10 : maximum >= 10 ? maximum + 10 : maximum;
				var nx = -cubeMod(n - 1, 6) * 40;
				var ny = -cubeDiv(n - 1, 6) * 40;
				icon.style.backgroundPosition = "" + nx + " " + ny;
			}
		}
		rolling = -1; // Reroll.
	};

	var changeCounts = (x) => {
		setCounts(counts + x);
	};
	var changeMaximum = () => {
		if (buffer) {
			setMaximum(maximum);
		} else {
			setMaximum(maximum == 6 ? 20 : maximum == 20 ? 0 : 6);
		}
	};

	// Initialize settings.
	setCounts(counts);
	setMaximum(maximum);
</script><!--/Menu-->

<!--Main--><script>(async()=>{
	//var counts = 1; // Counts of dice.
	//var maximum = 6; // Maximum number.
	//var rolling = 0; // Rolling count.

	// Resize screen.
	cubeResizeScreen(300, 240);

	// Create sprites.
	var sprite = await cubeSprite("resource.svg", 40, 40);
	cubeDilute(0.1, sprite);
	cubeExpand(0.5, sprite);
	var sprites = [];
	for (var i = 0; i < 30; i++) {
		if (buffer) {
			sprites[i] = await cubeBufferSprite(buffer);
		} else {
			sprites[i] = await cubeSprite("resource.svg", 40, 40);
		}
	}

	// Main loop.
	var counter = 0;
	while (true) {

		// Sprite lines and rows.
		var lineMax = maximum > 0 && !buffer ? cubeSqrt(counts - 1) + 1 : 20;
		var lines = cubeDiv(counts - 1, lineMax) + 1;
		var rows = [];
		for (var i = 0; i < lines; i++) {
			rows[i] = i > 0 ? lineMax : (cubeMod(counts - 1, lineMax) + 1);
		}

		// Sprite frame.
		var frameMax = maximum > 0 ? maximum : 10;
		var frameMin = maximum > 0 ? 1 : 0;
		var randoms = [];

		// Sprite scale and angle.
		var scale = 5 / ((counts < lineMax ? counts : lines >= lineMax ? lines : lineMax) + 1);
		var angle = 0;

		// Rolling dice.
		var result = 0;
		for (rolling = 1; rolling >= 1; rolling++) {

			// Screen size.
			var size = cubeScreenSize();

			// Wait for input.
			await cubeReadJoypad(0);
			if (result > 0) {

				// Restart to roll dice.
				if (cubeJoypadMotion()) {
					if (rolling > 10) {
						result = 0;
						rolling = 0;
					}
				}
			} else {

				// Hold to rolling dice.
				if (cubeJoypadMotion()) {
					rolling = 1;

				// Timeout and show result.
				} else if (rolling > 60) {
					for (var y = 0; y < lines; y++) {
						for (var x = 0; x < rows[y]; x++) {
							result += randoms[lineMax*y+x];
						}
					}
					angle = 0;
					rolling = 1;
					counter++;
				}
			}

			// Roll sprites.
			if (result <= 0) {
				angle = cubeMod(angle + 20, 360);
				for (var y = 0; y < lines; y++) {
					for (var x = 0; x < rows[y]; x++) {
						var framePlus = buffer ? (lineMax * y + x) * frameMax : 0;
						if (frameMax < 10) {
							randoms[lineMax*y+x] = cubeRandom(frameMax) + frameMin + framePlus;
						} else {
							randoms[lineMax*y+x] = cubeMod(cubeRandom(frameMax), 20) + frameMin + 10;
						}
					}
				}
			}

			// Update counter sprite.
			var n = result <= 0 ? counter : counter - 1;
			var mx = size.x * 0.8, my = size.y * 1;
			var ox = (size.x - mx) * 0.5, oy = (size.y - my) * 0.5;
			cubeAnimate(n > 0 ? cubeMod(n - 1, 20) + 10 : 9, sprite);
			cubeMove(ox + mx / 2, 16, sprite);

			// Update sprites.
			var s = rolling < 5 ? scale * (0.8 + 0.04 * rolling) : scale;
			for (var y = 0; y < lines; y++) {
				for (var x = 0; x < rows[y]; x++) {
					var i = lineMax * y + x;
					cubeAnimate(randoms[i] - 1, sprites[i]);
					cubeExpand(s, sprites[i]);
					cubeRotate(angle, sprites[i]);
					var sx = ox + mx * (x + 1) / (rows[y] + 1);
					var sy = oy + my * (y + 1) / (lines + 1);
					cubeMove(sx, sy, sprites[i]);
				}
			}

			// Clear screen.
			cubeClear();

			// Draw sprites.
			cubeDraw(sprite);
			for (var y = 0; y < lines; y++) {
				for (var x = 0; x < rows[y]; x++) {
					var i = lineMax * y + x;
					cubeDraw(sprites[i]);
				}
			}

			await cubeWait(10);
		}
	}
})();</script><!--/Main-->
</body>
</html>
